<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Geo War</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			background-color: #FAFAFA;
			color: #050505;
			font-family: Forum, sans-serif;
		}
	</style>
</head>

<body>
	<script>
		'use strict';

		const STATIC_VERT = `
		attribute vec2 a_position;
		void main() {
			gl_Position = vec4(a_position, 0.0, 1.0);
		}
	`;

		const GLOW_FRAG = `
		precision mediump float;
		uniform sampler2D u_texture;
		void main() {
			gl_FragColor = texture2D(u_texture, gl_FragCoord.xy / vec2(1920.0, 1080.0));
		}
	`;

		const CRT_FRAG = `
		precision mediump float;
		uniform sampler2D u_texture;
		void main() {
			gl_FragColor = texture2D(u_texture, gl_FragCoord.xy / vec2(1920.0, 1080.0));
			gl_FragColor.rgb *= vec3(1.0, 0.9, 0.8); // CRT effect
		}
	`;

		const CONFIG = {
			DEBUG: true,
			WIDTH: 1920,
			HEIGHT: 1080,
			TILE_SIZE: 50,
			GRID_SIZE: 25,
			FPS_TARGET: 60,
			COLORS: [
				'#FAFAFA',
				'#004080',
				'#808000',
				'#400000',
				'#C8C8C8',
				'#C8C8C8',
				'#408080',
				'#050505',
				'#004080',
				'#004080',
				'#408080',
				'#050505',
				'#004080',
				'#004080',
				'#400080',
				'#808000',
				'#400000',
				'#400080',
				'#408080',
				'#050505',
				'#004080',
				'#004080',
				'#050505',
				'#050505',
				'#050505',
				'#400000',
				'#808000',
				'#050505',
				'#400000',
				'#400000',
				'#808000',
				'#408080',
				'#408080',
				'#400000',
				'#400000',
				'#400000',
				'#808000',
				'#808000',
				'#050505',
			]
		};

		class SfxrParams {
			ss(values) {
				for (let i = 0; i < 24; i++) {
					this[String.fromCharCode(97 + i)] = values[i] || 0;
				}

				if (this['c'] < .01) {
					this['c'] = .01;
				}

				var totalTime = this['b'] + this['c'] + this['e'];
				if (totalTime < 0.18) {
					var multiplier = .18 / totalTime;
					this['b'] *= multiplier;
					this['c'] *= multiplier;
					this['e'] *= multiplier;
				}
			}
		}

		class SfxrSynth {
			constructor() {
				this._p = new SfxrParams();
				var _envelopeLength0,
					_envelopeLength1,
					_envelopeLength2,
					_period,
					_maxPeriod,
					_slide,
					_deltaSlide,
					_changeAmount,
					_changeTime,
					_changeLimit,
					_squareDuty,
					_dutySweep;
			}
			r() {
				const p = this._p;

				_period = 100 / (p['f'] * p['f'] + .001);
				_maxPeriod = 100 / (p['g'] * p['g'] + .001);

				_slide = 1 - p['h'] * p['h'] * p['h'] * .01;
				_deltaSlide = -p['i'] * p['i'] * p['i'] * .000001;

				if (!p['a']) {
					_squareDuty = .5 - p['n'] / 2;
					_dutySweep = -p['o'] * .00005;
				}

				_changeAmount = 1 + p['l'] * p['l'] * (p['l'] > 0 ? -.9 : 10);
				_changeTime = 0;
				_changeLimit = p['m'] == 1 ? 0 : (1 - p['m']) * (1 - p['m']) * 20000 + 32;
			}

			tr() {
				this.r();

				const p = this._p;

				_envelopeLength0 = p['b'] * p['b'] * 100000;
				_envelopeLength1 = p['c'] * p['c'] * 100000;
				_envelopeLength2 = p['e'] * p['e'] * 100000 + 12;
				return ((_envelopeLength0 + _envelopeLength1 + _envelopeLength2) / 3 | 0) * 3;
			}

			sw(buffer, length) {
				const p = this._p;

				const _filters = p['s'] != 1 || p['v'],
					_hpFilterCutoff = p['v'] * p['v'] * .1,
					_hpFilterDeltaCutoff = 1 + p['w'] * .0003,
					_lpFilterCutoff = p['s'] * p['s'] * p['s'] * .1,
					_lpFilterDeltaCutoff = 1 + p['t'] * .0001,
					_lpFilterOn = p['s'] != 1,
					_masterVolume = p['x'] * p['x'],
					_minFreqency = p['g'],
					_phaser = p['q'] || p['r'],
					_phaserDeltaOffset = p['r'] * p['r'] * p['r'] * .2,
					_phaserOffset = p['q'] * p['q'] * (p['q'] < 0 ? -1020 : 1020),
					_repeatLimit = p['p'] ? ((1 - p['p']) * (1 - p['p']) * 20000 | 0) + 32 : 0,
					_sustainPunch = p['d'],
					_vibratoAmplitude = p['j'] / 2,
					_vibratoSpeed = p['k'] * p['k'] * .01,
					_waveType = p['a'];

				let _envelopeLength = _envelopeLength0,
					_envelopeOverLength0 = 1 / _envelopeLength0,
					_envelopeOverLength1 = 1 / _envelopeLength1,
					_envelopeOverLength2 = 1 / _envelopeLength2;

				let _lpFilterDamping = 5 / (1 + p['u'] * p['u'] * 20) * (.01 + _lpFilterCutoff);
				if (_lpFilterDamping > .8) {
					_lpFilterDamping = .8;
				}

				_lpFilterDamping = 1 - _lpFilterDamping;

				var _finished = false,
					_envelopeStage = 0,
					_envelopeTime = 0,
					_envelopeVolume = 0,
					_hpFilterPos = 0,
					_lpFilterDeltaPos = 0,
					_lpFilterOldPos,
					_lpFilterPos = 0,
					_periodTemp,
					_phase = 0,
					_phaserInt,
					_phaserPos = 0,
					_pos,
					_repeatTime = 0,
					_sample,
					_superSample,
					_vibratoPhase = 0;

				const _phaserBuffer = new Array(1024),
					_noiseBuffer = new Array(32);
				for (let i = _phaserBuffer.length; i--;) {
					_phaserBuffer[i] = 0;
				}

				for (let i = _noiseBuffer.length; i--;) {
					_noiseBuffer[i] = (Math.random() * 2 - 1);
				}

				for (let i = 0; i < length; i++) {
					if (_finished) {
						return i;
					}

					if (_repeatLimit) {
						if (++_repeatTime >= _repeatLimit) {
							_repeatTime = 0;
							this.r();
						}
					}

					if (_changeLimit) {
						if (++_changeTime >= _changeLimit) {
							_changeLimit = 0;
							_period *= _changeAmount;
						}
					}

					_slide += _deltaSlide;
					_period *= _slide;

					if (_period > _maxPeriod) {
						_period = _maxPeriod;
						if (_minFreqency > 0) {
							_finished = true;
						}
					}

					_periodTemp = _period;

					if (_vibratoAmplitude > 0) {
						_vibratoPhase += _vibratoSpeed;
						_periodTemp *= 1 + Math.sin(_vibratoPhase) * _vibratoAmplitude;
					}

					_periodTemp |= 0;
					if (_periodTemp < 8) {
						_periodTemp = 8;
					}

					if (!_waveType) {
						_squareDuty += _dutySweep;
						if (_squareDuty < 0) {
							_squareDuty = 0;
						} else if (_squareDuty > .5) {
							_squareDuty = .5;
						}
					}

					if (++_envelopeTime > _envelopeLength) {
						_envelopeTime = 0;

						switch (++_envelopeStage) {
							case 1:
								_envelopeLength = _envelopeLength1;
								break;
							case 2:
								_envelopeLength = _envelopeLength2;
						}
					}

					switch (_envelopeStage) {
						case 0:
							_envelopeVolume = _envelopeTime * _envelopeOverLength0;
							break;
						case 1:
							_envelopeVolume = 1 + (1 - _envelopeTime * _envelopeOverLength1) * 2 * _sustainPunch;
							break;
						case 2:
							_envelopeVolume = 1 - _envelopeTime * _envelopeOverLength2;
							break;
						case 3:
							_envelopeVolume = 0;
							_finished = true;
					}

					if (_phaser) {
						_phaserOffset += _phaserDeltaOffset;
						_phaserInt = _phaserOffset | 0;
						if (_phaserInt < 0) {
							_phaserInt = -_phaserInt;
						} else if (_phaserInt > 1023) {
							_phaserInt = 1023;
						}
					}

					if (_filters && _hpFilterDeltaCutoff) {
						_hpFilterCutoff *= _hpFilterDeltaCutoff;
						if (_hpFilterCutoff < .00001) {
							_hpFilterCutoff = .00001;
						} else if (_hpFilterCutoff > .1) {
							_hpFilterCutoff = .1;
						}
					}

					_superSample = 0;
					for (let j = 8; j--;) {
						_phase++;
						if (_phase >= _periodTemp) {
							_phase %= _periodTemp;
							if (_waveType == 3) {
								for (let n = _noiseBuffer.length; n--;) {
									_noiseBuffer[n] = (Math.random() * 2 - 1);
								}
							}
						}

						switch (_waveType) {
							case 0:
								_sample = ((_phase / _periodTemp) < _squareDuty) ? .5 : -.5;
								break;
							case 1:
								_sample = 1 - _phase / _periodTemp * 2;
								break;
							case 2:
								_pos = _phase / _periodTemp;
								_pos = (_pos > .5 ? _pos - 1 : _pos) * 6.28318531;
								_sample = 1.27323954 * _pos + .405284735 * _pos * _pos * (_pos < 0 ? 1 : -1);
								_sample = .225 * ((_sample < 0 ? -1 : 1) * _sample * _sample - _sample) + _sample;
								break;
							case 3:
								_sample = _noiseBuffer[Math.abs(_phase * 32 / _periodTemp | 0)];
						}

						if (_filters) {
							_lpFilterOldPos = _lpFilterPos;
							_lpFilterCutoff *= _lpFilterDeltaCutoff;
							if (_lpFilterCutoff < 0) {
								_lpFilterCutoff = 0;
							} else if (_lpFilterCutoff > .1) {
								_lpFilterCutoff = .1;
							}

							if (_lpFilterOn) {
								_lpFilterDeltaPos += (_sample - _lpFilterPos) * _lpFilterCutoff;
								_lpFilterDeltaPos *= _lpFilterDamping;
							} else {
								_lpFilterPos = _sample;
								_lpFilterDeltaPos = 0;
							}

							_lpFilterPos += _lpFilterDeltaPos;

							_hpFilterPos += _lpFilterPos - _lpFilterOldPos;
							_hpFilterPos *= 1 - _hpFilterCutoff;
							_sample = _hpFilterPos;
						}

						if (_phaser) {
							_phaserBuffer[_phaserPos % 1024] = _sample;
							_sample += _phaserBuffer[(_phaserPos - _phaserInt + 1024) % 1024];
							_phaserPos++;
						}

						_superSample += _sample;
					}

					_superSample *= .125 * _envelopeVolume * _masterVolume;

					buffer[i] = _superSample >= 1 ? 32767 : _superSample <= -1 ? -32768 : _superSample * 32767 | 0;
				}

				return length;
			}
		}

		const enharmonics = 'B#-C|C#-Db|D|D#-Eb|E-Fb|E#-F|F#-Gb|G|G#-Ab|A|A#-Bb|B-Cb';
		const middleC = 440 * Math.pow(Math.pow(2, 1 / 12), -9);
		const numeric = /^[0-9.]+$/;
		const octaveOffset = 4;
		const space = /\s+/;
		const num = /(\d+)/;
		const offsets = {};

		enharmonics.split('|').forEach((val, i) => {
			val.split('-').forEach(note => {
				offsets[note] = i;
			});
		});

		class Note {
			constructor(str) {
				const couple = str.split(space);
				this.frequency = Note.getFrequency(couple[0]) || 0;
				this.duration = Note.getDuration(couple[1]) || 0;
			}

			static getFrequency(name) {
				const couple = name.split(num);
				const distance = offsets[couple[0]];
				const octaveDiff = (couple[1] || octaveOffset) - octaveOffset;
				const freq = middleC * Math.pow(Math.pow(2, 1 / 12), distance);
				return freq * Math.pow(2, octaveDiff);
			}

			static getDuration(symbol) {
				if (!symbol) return 0;
				return numeric.test(symbol) ? parseFloat(symbol) :
					symbol.toLowerCase().split('').reduce((prev, curr) => {
						return prev + (curr === 'w' ? 4 : curr === 'h' ? 2 :
							curr === 'q' ? 1 : curr === 'e' ? 0.5 :
								curr === 's' ? 0.25 : 0);
					}, 0);
			}
		}

		class Sequence {
			constructor(ac, tempo, arr) {
				this.ac = ac || new AudioContext();
				this.createFxNodes();
				this.tempo = tempo || 120;
				this.loop = true;
				this.smoothing = 0;
				this.staccato = 0;
				this.notes = [];
				this.osc = null;
				this.gain = null;
				this.customWave = null;
				this.waveType = 'square';
				if (arr) {
					this.push(...arr);
				}
			}

			createFxNodes() {
				const eq = [['bass', 100], ['mid', 1000], ['treble', 2500]];
				let prev = this.gain = this.ac.createGain();
				eq.forEach(config => {
					const filter = this[config[0]] = this.ac.createBiquadFilter();
					filter.type = 'peaking';
					filter.frequency.value = config[1];
					prev.connect(filter);
					prev = filter;
				});
				prev.connect(this.ac.destination);
				return this;
			}

			push(...notes) {
				notes.forEach(note => {
					this.notes.push(note instanceof Note ? note : new Note(note));
				});
				return this;
			}

			createCustomWave(real, imag) {
				if (!imag) {
					imag = real;
				}

				this.waveType = 'custom';

				this.customWave = [new Float32Array(real), new Float32Array(imag)];
			}

			createOscillator() {
				this.stop();
				this.osc = this.ac.createOscillator();

				if (this.customWave) {
					const wave = this.ac.createPeriodicWave(this.customWave[0], this.customWave[1]);
					this.osc.setPeriodicWave(wave);
				} else {
					this.osc.type = this.waveType;
				}

				this.osc.connect(this.gain);
				return this;
			}

			scheduleNote(index, when) {
				const note = this.notes[index];
				const duration = 60 / this.tempo * note.duration;
				const cutoff = duration * (1 - (this.staccato || 0));

				this.setFrequency(note.frequency, when);

				if (this.smoothing && note.frequency) {
					this.slide(index, when, cutoff);
				}

				this.setFrequency(0, when + cutoff);
				return when + duration;
			}

			getNextNote(index) {
				return this.notes[index < this.notes.length - 1 ? index + 1 : 0];
			}

			getSlideStartDelay(duration) {
				return duration - Math.min(duration, 60 / this.tempo * this.smoothing);
			}

			slide(index, when, cutoff) {
				const next = this.getNextNote(index);
				const launch = this.getSlideStartDelay(cutoff);
				this.setFrequency(this.notes[index].frequency, when + launch);
				this.rampFrequency(next.frequency, when + cutoff);
				return this;
			}

			setFrequency(freq, when) {
				if (this.osc) {
					this.osc.frequency.setValueAtTime(freq, when);
				}
				return this;
			}

			rampFrequency(freq, when) {
				if (this.osc) {
					this.osc.frequency.linearRampToValueAtTime(freq, when);
				}
				return this;
			}

			play(when) {
				when = typeof when === 'number' ? when : this.ac.currentTime;
				this.createOscillator();
				this.osc.start(when);

				let time = when;
				this.notes.forEach((note, i) => {
					time = this.scheduleNote(i, time);
				});

				this.osc.stop(time);
				this.osc.onended = this.loop ? () => this.play(time) : null;

				return this;
			}

			stop() {
				if (this.osc) {
					this.osc.onended = null;
					this.osc.stop();
					this.osc.disconnect();
					this.osc = null;
				}
				return this;
			}
		}

		class GeoWar {
			constructor() {
				this.state = {
					debug: CONFIG.DEBUG,
					gameOver: false,
					onyxMode: false,
					launchFromOnyxMode: false,
					score: 0,
					wave: 1,
					frame: 0,
					lastTime: 0,
					dt: 0,

					viewPort: [(CONFIG.WIDTH - CONFIG.GRID_SIZE * CONFIG.TILE_SIZE) / 2,
					(CONFIG.HEIGHT - CONFIG.GRID_SIZE * CONFIG.TILE_SIZE) / 2,
					CONFIG.WIDTH / 2 - 30, CONFIG.HEIGHT / 2 - 30],

					slowMotion: 0.3,
					mapPixels: CONFIG.GRID_SIZE * CONFIG.TILE_SIZE,
					keys: {
						'65': 1, // A
						'87': 2, // W
						'68': 4, // D
						'83': 8  // S
					},
					ship: {
						x: CONFIG.TILE_SIZE * 10.5,
						y: CONFIG.TILE_SIZE * 10.5,
						size: 16,
						angle: 0,
						speed: 150,
						fireCooldown: 0,
						fireRate: 12,
						phaseCooldown: 0,
						phaseDuration: 0
					},
					shipShape: [[0, 1, 0, -1], [-1, 1, 0.5, 1]],
					enemies: [],
					bullets: [],
					particles: [],
					map: [],
					spatialHashing: {},
					keyMap: 0,
					coords: [0, 0, 0],
					summons: [],
					triggers: {},
					shakeScreen: [0, 0],
					glitchTime: 0,
					GLITCH: [0, 0, 0, 0, 0, 0, 0],
					audioCtx: null,
					sequences: {},
					music: {},
					sounds: {},
					message: '',
					record: 0,
					newRecord: false,
					splashScreen: true,
					animationLine: 0,
					distanceLine: 30,
					controlHelp: false,
					fade: 0,
					bannerEndMessage: false,
					endBannerCounter: 0,
					stats: {
						fps: null,
						processing: null,
						memory: null,
						enemies: null
					}
				};

				this.init();
			}

			init() {
				this.initPerformanceStats();
				this.initCanvas();
				this.initWebGL();
				this.initAudio();
				this.initMusic();
				this.initGameState();
				this.setupEventListeners();
				this.launchGameLoop();
			}

			initPerformanceStats() {
				if (!this.state.debug) return;

				this.state.stats.fps = new Stats();
				this.state.stats.processing = new Stats();
				this.state.stats.memory = new Stats();
				this.state.stats.enemies = new Stats();

				const panels = [
					{ stats: this.state.stats.fps, left: '0px' },
					{ stats: this.state.stats.processing, left: '100px' },
					{ stats: this.state.stats.memory, left: '200px' },
					{ stats: this.state.stats.enemies, left: '300px' }
				];

				panels.forEach(({ stats, left }) => {
					stats.dom.style.left = left;
					document.body.appendChild(stats.dom);
				});
			}

			initCanvas() {
				this.canvas = document.createElement('canvas');
				this.canvas.width = CONFIG.WIDTH;
				this.canvas.height = CONFIG.HEIGHT;
				this.ctx = this.canvas.getContext('2d');
				this.glCanvas = document.createElement('canvas');
				this.glCanvas.width = CONFIG.WIDTH;
				this.glCanvas.height = CONFIG.HEIGHT;
				this.gl = this.glCanvas.getContext('webgl', { preserveDrawingBuffer: true }) ||
					this.glCanvas.getContext('experimental-webgl', { preserveDrawingBuffer: true });

				// DOM
				document.body.appendChild(this.canvas);
				document.body.appendChild(this.glCanvas);

				// CSS
				this.canvas.style.position = 'fixed';
				this.canvas.style.top = '0';
				this.canvas.style.left = '0';
			}

			initWebGL() {
				if (!this.gl) return;

				// WebGL
				this.gl.viewport(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
				this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);
				this.initWebGLResources();
			}

			initWebGLResources() {
				const buffer = this.gl.createBuffer();
				this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
				this.gl.bufferData(
					this.gl.ARRAY_BUFFER,
					new Float32Array([
						-1.0, -1.0,
						1.0, -1.0,
						-1.0, 1.0,
						-1.0, 1.0,
						1.0, -1.0,
						1.0, 1.0
					]),
					this.gl.STATIC_DRAW
				);

				this.shaders = {
					glow: this.createShaderProgram(STATIC_VERT, GLOW_FRAG),
					crt: this.createShaderProgram(STATIC_VERT, CRT_FRAG),
				};

				this.fbo1 = this.createFBO();
				this.fbo2 = this.createFBO();

				this.textureGame = this.createTexture();
			}

			createShaderProgram(vertexSrc, fragmentSrc) {
				return { program: program, uniforms: {} };
			}

			createFBO() {
				return { handle: handle, texture: color };
			}

			createTexture() {
				return texture;
			}

			initAudio() {
				try {
					const AudioContext = window.AudioContext || window.webkitAudioContext;
					this.state.audioCtx = new AudioContext();
					this.audioDest = this.state.audioCtx.createDynamicsCompressor();
					const gain = this.state.audioCtx.createGain();
					gain.gain.value = 0.3;
					this.audioDest.connect(gain);
					gain.connect(this.state.audioCtx.destination);

					this.synth = new SfxrSynth();
					this._generateSounds();
				} catch (e) {
					console.warn('Web Audio API is not available. Game will run without sound.', e);
					this.audio = this.play = () => { };
				}
			}

			initMusic() {
				if (!this.state.audioCtx) return;

				const ac = this.state.audioCtx;
				const tempo = 140;
				const when = ac.currentTime;

				this.state.music = {
					bb1: 'Bb1 s',
					d2: 'D2 s',
					ab1: 'Ab1 s',
					g2be: 'G2b e',
					g2e: 'G2 e',
					c2e: 'C2 e',
				};

				this.state.music.lead = [
					this.state.music.bb1, this.state.music.d2, this.state.music.bb1, this.state.music.d2,
					this.state.music.bb1, this.state.music.d2, this.state.music.bb1, this.state.music.d2,
					this.state.music.bb1, this.state.music.d2, this.state.music.bb1, this.state.music.d2,
					this.state.music.bb1, this.state.music.d2, this.state.music.bb1, this.state.music.d2,
					this.state.music.ab1, this.state.music.d2, this.state.music.ab1, this.state.music.d2,
					this.state.music.ab1, this.state.music.d2, this.state.music.ab1, this.state.music.d2,
					this.state.music.ab1, this.state.music.d2, this.state.music.ab1, this.state.music.d2,
					this.state.music.ab1, this.state.music.d2, this.state.music.ab1, this.state.music.d2,
				];

				this.state.music.harmony = [
					this.state.music.g2e, this.state.music.g2be, this.state.music.g2e, this.state.music.g2be,
					this.state.music.g2e, this.state.music.g2be, this.state.music.g2e, this.state.music.g2be,
					this.state.music.c2e, this.state.music.g2be, this.state.music.c2e, this.state.music.g2be,
					this.state.music.c2e, this.state.music.g2be, this.state.music.c2e, this.state.music.g2be
				];

				this.state.music.bass2 = ['- w', 'D1 s', '- s', 'D1 e', '- q', '- m', '- w'];
				this.state.music.basebass = ['C1 e', '- e', 'A1 e', '- e'];
				this.state.music.bass = this.state.music.basebass;

				const sequence1 = new Sequence(ac, tempo, this.state.music.lead);
				sequence1.staccato = 0.75;
				sequence1.gain.gain.value = 0.10;
				this.state.sequences.sequence1 = sequence1;

				const sequence2 = new Sequence(ac, tempo, this.state.music.harmony);
				sequence2.staccato = 0.50;
				sequence2.gain.gain.value = 0.10;
				this.state.sequences.sequence2 = sequence2;

				const sequence3 = new Sequence(ac, tempo, this.state.music.bass);
				sequence3.staccato = 0.05;
				sequence3.smoothing = 0.25;
				sequence3.gain.gain.value = 0.10;
				this.state.sequences.sequence3 = sequence3;

				const sequence4 = new Sequence(ac, tempo, this.state.music.bass2);
				sequence4.staccato = 0.05;
				sequence4.gain.gain.value = 0.10;
				this.state.sequences.sequence4 = sequence4;

				this.state.sequences.sequence1.play(when + 50);
				this.state.sequences.sequence3.play(when + 10);
				this.state.sequences.sequence4.play(when + 1);
				this.state.sequences.sequence2.play(when + 100);
			}

			_generateWav(settings) {
				this.synth._p.ss(settings);
				const len = this.synth.tr();
				const data = new Uint8Array(44 + len * 2);
				const view = new DataView(data.buffer);

				this.synth.sw(new Uint16Array(data.buffer, 44), len);

				view.setUint32(0, 0x46464952, true);  // "riff"
				view.setUint32(4, 36 + len * 2, true); // Size - 8
				view.setUint32(8, 0x45564157, true);  // "wav"
				view.setUint32(12, 0x20746d66, true); // "fmt"
				view.setUint32(16, 16, true);         // Subchunk 1
				view.setUint16(20, 1, true);          // Format - PCM
				view.setUint16(22, 1, true);          // Channels
				view.setUint32(24, 44100, true);      // Sample Rate
				view.setUint32(28, 44100 * 2, true);  // Bitrate
				view.setUint16(32, 2, true);          // Block Align
				view.setUint16(34, 16, true);         // Bits Per Sample
				view.setUint32(36, 0x61746164, true); // "data"
				view.setUint32(40, len * 2, true);    // Subchunk 2

				return data.buffer;
			}

			_createSound(settings) {
				const sound = [];
				if (!this.state.audioCtx) return sound;
				const buffer = this._generateWav(settings);
				this.state.audioCtx.decodeAudioData(buffer, (decodedBuffer) => {
					sound[0] = decodedBuffer;
				});
				return sound;
			}

			_createMutatedSounds(baseSettings, count) {
				const sounds = [];
				for (let i = 0; i < count; i++) {
					const newSettings = [...baseSettings];
					newSettings[5] = (i - count / 2) * 0.05 + (baseSettings[5] || 0);
					sounds.push(this._createSound(newSettings));
				}
				return sounds;
			}

			_generateSounds() {
				this.state.sounds.gameStarts = this._createSound([3, 0.2421, 0.1876, 0.1891, 0.2844, 0.5008, , -0.0619, 0.2484, , 0.0432, -0.7113, 0.3743, 0.007, 0.0008, 0.0474, -0.0023, 0.705, 0.7098, 0.0034, 0.011, 0.0259, 0.0005, 0.42]);
				this.state.sounds.fireSounds = this._createMutatedSounds([0, , 0.12, 0.14, 0.3, 0.8, , -0.3399, 0.04, , , -0.04, , 0.51, -0.02, , -0.74, , 0.21, 0.24, , , 0.02, 0.41], 6);
				this.state.sounds.totemAppears = this._createSound([1, , 0.38, , 0.03, 0.03, , 0.8799, 0.96, 0.9411, 0.9785, -0.9219, 0.82, 0.7513, 0.6049, 0.8, -0.6041, -0.8402, 0.28, 0.7, 0.78, 0.1423, -0.7585, 0.5]);
				this.state.sounds.enemyDie = this._createSound([3, 0.0597, 0.11, 0.2, 0.2513, 0.5277, , 0.5841, -0.0248, -0.076, 0.5312, -0.2978, 0.7065, -0.9091, 0.4202, 0.966, 0.7036, 0.4575, 1, -0.9064, 0.6618, 0.0266, -0.0655, 0.42]);
				this.state.sounds.shipSpeedUp = this._createSound([2, , 0.09, 0.06, 0.45, 0.27, 0.02, -0.28, 0.82, 0.41, 0.58, -0.88, 0.07, 0.448, -0.355, 1, 0.54, -0.073, 1, , , , , 0.42]);
				this.state.sounds.totemDestroyed = this._createSound([3, 0.002, 0.6302, 0.499, 0.0804, 0.5224, , -0.0324, 0.0004, 0.5448, , -0.7762, -0.1765, 0.6762, -0.4386, 0.7747, -0.0347, -0.2051, 0.931, -0.0732, 0.4693, 0.1444, , 0.42]);
				this.state.sounds.shipDie = this._createSound([1, 0.145, 0.2094, 0.4645, 0.4954, 0.7134, , -0.1659, -0.8866, 0.9733, , -0.572, -0.7927, -0.1186, 0.4699, 0.6044, 0.4604, 0.1762, 0.9998, 0.0236, 0.1554, , 0.659, 0.42]);
				this.state.sounds.glitchStop = this._createSound([1, 0.0076, 0.66, , , 0.09, , 0.96, 0.32, 0.1, 0.97, -1, , 0.0615, -0.1587, 1, , -0.02, 0.83, 0.12, 0.23, 0.0231, -0.02, 0.96]);
				this.state.sounds.hitSounds = this._createMutatedSounds([3, 0.0691, 0.183, 0.0949, 0.5678, 0.46, , -0.0001, , , , -0.542, -0.2106, -0.2402, -0.1594, , -0.3133, -0.0707, 0.1592, -0.4479, 0.5788, 0.0169, -0.919, 0.42], 8);
				this.state.sounds.openingGlitch = this._createSound([3, 0.0258, 0.16, 0.0251, 0.16, 0.05, , -0.86, -0.4088, 0.0956, 0.256, -0.62, , -0.0006, -0.0352, , -0.0882, -0.0443, 0.9219, -0.0531, 0.8727, 0.031, 0.0002, 0.6]);
				this.state.sounds.bossSummon = this._createSound([0, 0.95, 0.34, 0.03, 0.05, 0.51, , 0.96, 0.84, 0.05, 0.51, -0.84, 0.99, 0.82, , 1, , -0.88, 0.87, 1, 0.5, 0.21, 0.94, 0.65]);
			}

			initGameState() {
				this.initMap();
				this.loadGameState();
				this.randomGlitch();
			}

			initMap() {
				for (let i = 0; i < CONFIG.GRID_SIZE; i++) {
					this.state.map.push([]);
					for (let j = 0; j < CONFIG.GRID_SIZE; j++) {
						this.state.map[i].push(0);
					}
				}

				this.initTriggers();
			}

			loadGameState() {
				this.state.record = parseFloat(localStorage.getItem('agar3sjs13k-record') || 0);
				this.state.onyxMode = !!localStorage.getItem('agar3sjs13k-gm');

				if (this.state.onyxMode) {
					this.state.shipShape = [[0, -0.5, -0.25, -1, -0.5, -0.4, -0.5, -0.25, 0, 0.25, 0.5, 0.4, 0.5, 1, 0.25, 0.5,], [-0.25, 0, -1, 0.25, 0.75, 0.5, 0.25, 0.2, 0.8, 0.2, 0.25, 0.5, 0.75, 0.25, -1, 0]];
					this.state.ship.speed = 160;
					this.state.ship.size = 20;
					this.state.ship.fireRate = 22;
				}
			}

			initTriggers() {
			}

			setupEventListeners() {
				this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
				this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
				this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
				document.addEventListener('keydown', this.handleKeyDown.bind(this));
				document.addEventListener('keyup', this.handleKeyUp.bind(this));
				document.getElementById('f').addEventListener('click', this.toggleFullscreen.bind(this));
			}

			launchGameLoop() {
				const loop = (timestamp) => {
					if (!this.state.lastTime) this.state.lastTime = timestamp;
					this.state.dt = Math.min(0.1, (timestamp - this.state.lastTime) / 1000);
					this.state.lastTime = timestamp;
					this.state.frame++;

					if (this.state.splashScreen) this.updateSplash();
					else if (this.state.bannerEndMessage) this.updateEnds();
					else if (this.state.GLITCH[6] < 0) this.update();

					this.render();

					if (this.state.debug) {
						this.state.stats.fps.begin();
						this.state.stats.processing.begin();
						this.state.stats.memory.begin();
						this.state.stats.enemies.begin();
					}

					requestAnimationFrame(loop);

					if (this.state.debug) {
						this.state.stats.fps.end();
						this.state.stats.processing.end();
						this.state.stats.memory.end();
						this.state.stats.enemies.end();
						this.state.stats.enemiesPanel.update(
							this.state.enemies.length, 1000
						);
					}
				};
				requestAnimationFrame(loop);
			}
			update() {

				if (this.state.gameOver || this.state.splashScreen) return;

				const { dt, ship, slowMotion } = this.state;
				const timeAdjustedDelta = dt * (ship.phaseCooldown > 0 ? slowMotion : 1);

				this.updatePlayer();
				this.updateBullets(timeAdjustedDelta);
				this.updateEnemies();
				this.updateParticles();
				this.updateTrigger();
				this.updateSummons();

				this.state.score += dt * 1000 * (ship.phaseCooldown > 0 ? slowMotion : 1);
			}
			updatePlayer() {
				const { dt, ship, viewPort, map, keyMap, keys, coords, mapPixels, slowMotion } = this.state;

				let speed = dt * ship.speed * (ship.phaseCooldown > 0 ? 1.4 : 1);

				const tileX = Math.round(ship.x / CONFIG.TILE_SIZE);
				const tileY = Math.round(ship.y / CONFIG.TILE_SIZE);
				if (map[tileY] && map[tileY][tileX] === 1) {
					speed -= 0.5;
				}

				// Movement
				if (keyMap & keys['65']) { // A
					ship.x -= speed;
					if (ship.x < ship.size) ship.x = ship.size;
					if (ship.x > viewPort[2] && ship.x < mapPixels - viewPort[2]) viewPort[0] += speed;
					if (viewPort[0] > 32) viewPort[0] = 32;
				}
				if (keyMap & keys['87']) { // W
					ship.y -= speed;
					if (ship.y < ship.size) ship.y = ship.size;
					if (ship.y > viewPort[3] && ship.y < mapPixels - viewPort[3]) viewPort[1] += speed;
					if (viewPort[1] > 27) viewPort[1] = 27;
				}
				if (keyMap & keys['83']) { // S
					ship.y += speed;
					if (ship.y > mapPixels - ship.size) ship.y = mapPixels - ship.size;
					if (ship.y > viewPort[3] && ship.y < mapPixels - viewPort[3]) viewPort[1] -= speed;
					if (viewPort[1] < -272) viewPort[1] = -272;
				}
				if (keyMap & keys['68']) { // D
					ship.x += speed;
					if (ship.x > mapPixels - ship.size) ship.x = mapPixels - ship.size;
					if (ship.x > viewPort[2] && ship.x < mapPixels - viewPort[2]) viewPort[0] -= speed;
					if (viewPort[0] < -67) viewPort[0] = -67;
				}

				ship.angle = this.getAngle([ship.x + viewPort[0], ship.y + viewPort[1]], coords);

				const killer = this.collideElements(ship);
				if (killer) return this.die(killer);

				if (coords[2] && ship.fireCooldown <= 0 && ship.phaseCooldown <= 0) {
					this.state.bullets.push({
						x: ship.x + this.shake(1, 2 + ship.fireRate / 30),
						y: ship.y + this.shake(1, 2 + ship.fireRate / 30),
						size: 2,
						speed: ship.speed * 2,
						angle: ship.angle + this.shake(1, 0.05 + 0.001 * ship.fireRate)
					});
					this.play(this.state.sounds.fireSounds[Math.floor(this.getRandomValue(this.state.sounds.fireSounds.length))]);
					ship.fireCooldown = 1 / ship.fireRate;
				} else {
					ship.fireCooldown -= dt;
				}

				if (coords[3] && ship.phaseCooldown <= 0 && ship.phaseDuration <= 0) {
					this.play(this.state.sounds.shipSpeedUp);
					ship.phaseCooldown = 0.55;
					ship.phaseDuration = 1.2;
				} else {
					ship.phaseCooldown -= dt;
					ship.phaseDuration -= dt;
				}
			}
			updateBullets(timeAdjustedDelta) {
				for (let i = this.state.bullets.length - 1; i >= 0; i--) {
					const bullet = this.state.bullets[i];

					bullet.x += Math.cos(bullet.angle) * bullet.speed * timeAdjustedDelta;
					bullet.y += Math.sin(bullet.angle) * bullet.speed * timeAdjustedDelta;

					if (this.isOutOfBounds(bullet.x, bullet.y)) {
						this.state.bullets.splice(i, 1);
						continue;
					}

					const enemy = this.collideElements(bullet);
					if (enemy) {
						this.handleBulletHit(bullet, enemy, i);
					}
				}
			}

			isOutOfBounds(x, y) {
				const { mapPixels } = this.state;
				return x < -20 || x > mapPixels + 20 || y < -20 || y > mapPixels + 20;
			}

			handleBulletHit(bullet, enemy, bulletIndex) {
				if (--enemy[6] > 0) {
					this.createParticles(bullet.x, bullet.y, -bullet.angle, 2, 10, 9);
				}
				this.state.bullets.splice(bulletIndex, 1);
				enemy[4] = 200;
				if (enemy[5] > 9) {
					this.play(this.state.sounds.hitSounds[Math.floor(this.getRandomValue(this.state.sounds.hitSounds.length))]);
				}
				this.updateEnemies();

				this.state.spatialHashing = {};

				for (let i = this.state.enemies.length - 1; i >= 0; i--) {
					const enemy = this.state.enemies[i];

					if (enemy[6] <= 0) {
						this.handleEnemyDeath(enemy, i);
						continue;
					}

					if (enemy[5] < 10) {
						this.updateMinionEnemy(enemy, i);
					} else {
						this.updateSpawnerEnemy(enemy);
					}

					this.addItem(enemy);
				}
			}

			updateParticles() {
				for (let i = this.state.particles.length - 1; i >= 0; i--) {
					const particle = this.state.particles[i];

					particle[0] += Math.cos(particle[2]) * this.getRandomValue(3, 2);
					particle[1] += Math.sin(particle[2]) * this.getRandomValue(3, 2);

					if (--particle[3] < 0) {
						this.state.particles.splice(i, 1);
					}
				}
			}
			createParticles(x, y, angle, many, life, color) {
				for (let h = -many; h < many; h++) {
					const particleZ = Math.PI / 2;
					this.state.particles.push([x, y, this.getRandomValue(particleZ * h, angle), life || 60, color]);
				}
			}
			render() {

				this.ctx.clearRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
				this.drawBackground();
				this.drawMap();
				this.drawCorruption();
				this.drawSummons();
				this.drawHero();
				this.drawEnemies();
				this.drawBullets();
				this.drawParticles();
				this.drawUI();
				this.drawPostProcessing();
			}
			drawBackground() {

			}
			drawMap() {

			}
			getHashKey(x, y) {

				return `${Math.round(x / CONFIG.TILE_SIZE)}-${Math.round(y / CONFIG.TILE_SIZE)}`;
			}
			addItem(item) {
				const hash = this.getHashKey(item[0], item[1]);
				if (!this.state.spatialHashing[hash]) {
					this.state.spatialHashing[hash] = [];
				}
				this.state.spatialHashing[hash].push(item);
			}
			collideElements(item) {
				const itemIsArray = Array.isArray(item);
				const itemX = itemIsArray ? item[0] : item.x;
				const itemY = itemIsArray ? item[1] : item.y;
				const itemSize = itemIsArray ? item[2] : item.size;

				const list = {};
				for (let i = 0; i < 9; i++) {
					const hash = this.getHashKey(
						itemX + (i % 3 - 1) * CONFIG.TILE_SIZE,
						itemY + (~~(i / 3) - 1) * CONFIG.TILE_SIZE
					);

					if (!list[hash] && this.state.spatialHashing[hash]) {
						list[hash] = 1;
						const elements = this.state.spatialHashing[hash];
						for (let j = 0; j < elements.length; j++) {
							const el = elements[j];
							if (this.getHypo(itemY - el[1], itemX - el[0]) < el[2] + itemSize) {
								return el;
							}
						}
					}
				}
				return null;
			}

			getAngle(p1, p2) {
				return Math.atan2(p2[1] - p1[1], p2[0] - p1[0]);
			}
			getHypo(p1, p2) {
				return Math.sqrt(p1 * p1 + p2 * p2);
			}
			shake(cond, val) {
				return cond ? this.getRandomValue(val * 2, -val) : 0;
			}
			getRandomValue(value, offset) {
				return Math.random() * (value || 1) + (offset || 0);
			}

			audio(conf) {

			}
			play(sound, pitchVar = 0.05) {
				if (!sound || !sound[0] || !this.state.audioCtx) return;

				const source = this.state.audioCtx.createBufferSource();
				source.buffer = sound[0];
				source.playbackRate.value = 1 + (Math.random() - 0.5) * pitchVar * 2;
				source.connect(this.audioDest);
				source.start(0);

				setTimeout(() => {
					try { source.disconnect(); } catch (e) { }
				}, (sound[0].duration * 1000) + 300);
			}
			handleMouseDown(e) {

			}
			toggleFullscreen(e) {

			}
			launchGame() {

			}
			die(killer) {
				console.log("Player died!");
				this.state.gameOver = true;
				this.play(this.state.sounds.shipDie);
				this.createParticles(this.state.ship.x, this.state.ship.y, this.state.ship.size, 10, 80, 6);
				Object.values(this.state.sequences).forEach(seq => seq.stop());
			}
		}

		const game = new GeoWar();

		(function () {
			const DEBUG = true;
			var Stats = function () {
				function h(a) { c.appendChild(a.dom); return a } function k(a) { for (var d = 0; d < c.children.length; d++)c.children[d].style.display = d === a ? "block" : "none"; l = a } var l = 0, c = document.createElement("div"); c.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000"; c.addEventListener("click", function (a) { a.preventDefault(); k(++l % c.children.length) }, !1); var g = (performance || Date).now(), e = g, a = 0, r = h(new Stats.Panel("FPS", "#0ff", "#002")), f = h(new Stats.Panel("MS", "#0f0", "#020"));
				if (self.performance && self.performance.memory) var t = h(new Stats.Panel("MB", "#f08", "#201")); k(0); return { REVISION: 16, dom: c, addPanel: h, showPanel: k, begin: function () { g = (performance || Date).now() }, end: function () { a++; var c = (performance || Date).now(); f.update(c - g, 200); if (c > e + 1E3 && (r.update(1E3 * a / (c - e), 100), e = c, a = 0, t)) { var d = performance.memory; t.update(d.usedJSHeapSize / 1048576, d.jsHeapSizeLimit / 1048576) } return c }, update: function () { g = this.end() }, domElement: c, setMode: k }
			};

			Stats.Panel = function (h, k, l) {
				var c = Infinity, g = 0, e = Math.round, a = e(window.devicePixelRatio || 1), r = 80 * a, f = 48 * a, t = 3 * a, u = 2 * a, d = 3 * a, m = 15 * a, n = 74 * a, p = 30 * a, q = document.createElement("canvas"); q.width = r; q.height = f; q.style.cssText = "width:80px;height:48px"; var b = q.getContext("2d"); b.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif"; b.textBaseline = "top"; b.fillStyle = l; b.fillRect(0, 0, r, f); b.fillStyle = k; b.fillText(h, t, u); b.fillRect(d, m, n, p); b.fillStyle = l; b.globalAlpha = .9; b.fillRect(d, m, n, p); return {
					dom: q, update: function (f,
						v) { c = Math.min(c, f); g = Math.max(g, f); b.fillStyle = l; b.globalAlpha = 1; b.fillRect(0, 0, r, m); b.fillStyle = k; b.fillText(e(f) + " " + h + " (" + e(c) + "-" + e(g) + ")", t, u); b.drawImage(q, d + a, m, n - a, p, d, m, n - a, p); b.fillRect(d + n - a, m, a, p); b.fillStyle = l; b.globalAlpha = .9; b.fillRect(d + n - a, m, a, e((1 - f / v) * p)) }
				}
			}; "object" === typeof module && (module.exports = Stats);

			function getAngle(p1, p2) {
				return Math.atan2(p2[1] - p1[1], p2[0] - p1[0]);
			}

			function getHypo(p1, p2) {
				return Math.sqrt(p1 * p1 + p2 * p2)
			}

			function glCreateShader(vert, frag) {
				var handle, type = gl.VERTEX_SHADER, src = vert;
				handle = gl.createShader(type);
				gl.shaderSource(handle, src);
				gl.compileShader(handle);
				var vertex = handle;
				if (DEBUG) {
					if (!gl.getShaderParameter(handle, gl.COMPILE_STATUS))
						throw gl.getShaderInfoLog(handle);
				}

				type = gl.FRAGMENT_SHADER;
				src = frag;
				handle = gl.createShader(type);
				gl.shaderSource(handle, src);
				gl.compileShader(handle);
				var fragment = handle;

				if (DEBUG) {
					if (!gl.getShaderParameter(handle, gl.COMPILE_STATUS))
						throw gl.getShaderInfoLog(handle);
				}

				var program = gl.createProgram();
				gl.attachShader(program, vertex);
				gl.attachShader(program, fragment);
				gl.linkProgram(program);

				if (DEBUG) {
					if (!gl.getProgramParameter(program, gl.LINK_STATUS))
						throw gl.getProgramInfoLog(program);
				}

				gl.useProgram(program);
				var p = gl.getAttribLocation(program, "p");
				gl.enableVertexAttribArray(p);
				gl.vertexAttribPointer(p, 2, gl.FLOAT, false, 0, 0);
				return [program];
			}

			function glBindShader(shader) {
				gl.useProgram(shader[0]);
			}

			function glUniformLocation(shader, name) {
				return shader[name] || (shader[name] = gl.getUniformLocation(shader[0], name));
			}

			function glCreateTexture() {
				var tex = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, tex);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				return tex;
			}

			function glSetTexture(t, value) {
				gl.bindTexture(gl.TEXTURE_2D, t);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
			}

			function glBindTexture(t, unit) {
				gl.activeTexture(gl.TEXTURE0 + unit);
				gl.bindTexture(gl.TEXTURE_2D, t);
				return unit;
			}

			function glCreateFBO() {
				var handle = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, handle);
				var color = glCreateTexture();
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, color, 0);
				return [handle, color];
			}

			var audioCtx, audioDest, audio, play;

			var AudioContext = window.AudioContext || window.webkitAudioContext;

			if (AudioContext) {
				audioCtx = new AudioContext();
				audioDest = audioCtx.createDynamicsCompressor();
				var gain = audioCtx.createGain();
				gain.gain.value = !!window.chrome ? 0.2 : 0.4;
				audioDest.connect(gain);
				gain.connect(audioCtx.destination);

				audio = function (conf) {
					var o = [];
					jsfxr(conf, audioCtx, function (buf) {
						o.push(buf);
					});
					return o;
				};
				play = function (o) {
					if (!o[0]) return;
					var source = audioCtx.createBufferSource();
					o[0].sampleRate += Math.round(Math.random() * 500)
					source.context.sampleRate += ~~getRandomValue(500);
					source.buffer = o[0];
					source.launch(0);
					source.connect(audioDest);
					setTimeout(function () {
						source.disconnect(audioDest);
					}, o[0].duration * 1000 + 300);
				};
			}
			else {
				audio = play = function () { };
			}

			var mapLetters = '0123456789?abcdefghijklmnopqrstuvwxyz .-\'/';
			var letters = [8767, 518, 1115, 1039, 1126, 1133, 1149, 7, 1151, 1135, 5123, 1143, 5391, 57, 4367, 121, 113, 1085, 1142, 4361, 30, 2672, 56, 694, 2230, 63, 1139, 2111, 3187, 1133, 4353, 62, 8752, 10294, 10880, 4736, 8713, 0, 16, 1088, 256, 8704];

			function drawSegment(xi, yi, offsetX, offsetY) {
				ctx.moveTo(xi, yi);
				ctx.lineTo(xi + offsetX, yi + offsetY);
			}

			function drawLetter14Segments(letter, x, y, size) {
				var size4 = size - 4;
				var size24 = size / 2 - 4;
				// *****
				// |\|/|
				// -- --
				// |\|/|
				// *****
				if (letter & 1) {
					drawSegment(x + 2, y - 1, size4, 0);
				}
				// ---
				// |\/*
				//  --
				// |\/|
				// ---
				if (letter & 2) {
					drawSegment(size + x + 1, y, 0, size - 1);
				}
				// ---
				// |\/|
				//  --
				// |\/*
				// ---
				if (letter & 4) {
					drawSegment(size + x + 1, size + y + 1, 0, size - 1);
				}
				// ---
				// |\/|
				//  --
				// |\/|
				// ***
				if (letter & 8) {
					drawSegment(x + 2, size * 2 + y + 1, size4, 0);
				}
				// ---
				// |\/|
				//  --
				// *\/|
				// ---
				if (letter & 16) {
					drawSegment(x - 1, y + size + 1, 0, size - 1);
				}
				// ---
				// *\/|
				//  --
				// |\/|
				// ---
				if (letter & 32) {
					drawSegment(x - 1, y, 0, size - 1);
				}
				// ---
				// |\/|
				//  *-
				// |\/|
				// ---
				if (letter & 64) {
					drawSegment(x + 2, size + y, size24, 0);
				}
				// ---
				// |*/|
				//  --
				// |/|\|
				// ---
				if (letter & 128) {
					drawSegment(x + 2, y + 2, size24, size4);
				}
				// -----
				// |\*/|
				// -- --
				// |/|\|
				// -----
				if (letter & 256) {
					drawSegment(size / 2 + x, y + 2, 0, size4);
				}
				// -----
				// |\|*|
				// -- --
				// |/|\|
				// -----
				if (letter & 512) {
					drawSegment(size + x - 2, y + 2, -size24, size4);
					drawSegment(size / 2 + x + 2, size + y - 2, size24, size + 4);
				}
				// -----
				// |\|/|
				// -- **
				// |/|\|
				// -----
				if (letter & 1024) {
					drawSegment(size / 2 + x + 2, size + y, size24, 0);
				}
				// -----
				// |\|/|
				// -- --
				// |/|*|
				// -----
				if (letter & 2048) {
					drawSegment(size / 2 + x + 2, size + y + 2, size24, size4);
				}
				// -----
				// |\|/|
				// -- --
				// |/*\|
				// -----
				if (letter & 4096) {
					drawSegment(size / 2 + x, size + y + 2, 0, size4);
				}
				// -----
				// |\|/|
				// -- --
				// |*|\|
				// -----
				if (letter & 8192) {
					drawSegment(x + 2, size * 2 + y - 2, size24, -size + 4);
				}
			}
			function drawWord(word, x, y, size, colorIndex, spacing) {
				ctx.save();
				ctx.beginPath();
				setContextAtrribute(colorIndex);
				for (var i = 0; i < word.length; i++) {
					drawLetter14Segments(letters[mapLetters.indexOf(word[i])], shakeScreen[0] + x - (size + spacing) * (word.length - i), shakeScreen[1] + y, size);
				}
				ctx.closePath();
				ctx.stroke();
				ctx.restore();
			}
			function drawWordCenter(word, x, y, size, colorIndex, spacing) {
				x += (size + spacing) * word.length / 2
				drawWord(word, x, y, size, colorIndex, spacing)
			}
			function drawWordLeft(word, x, y, size, colorIndex, spacing) {
				x += (size + spacing) * word.length;
				drawWord(word, x, y, size, colorIndex, spacing)
			}
			var wordAligns = [drawWordCenter, drawWord];

			function displayWord(word, x, y, size, colorIndexes, side, width) {
				width = width || colorIndexes.length;
				side = side || 0;
				var spacing = size < 25 ? 10 : size * 0.5;
				for (var i = 0; i < width; i++) {
					wordAligns[side](word, x + i, y + i, size, colorIndexes[i] || colorIndexes[0], spacing);
				}
			}
			// http://gizma.com/easing
			var linearTween = function (t, b, c, d) {
				return c * t / d + b;
			};

			var easeInQuad = function (t, b, c, d) {
				t /= d;
				return c * t * t + b;
			};

			var easeOutQuad = function (t, b, c, d) {
				t /= d;
				return -c * t * (t - 2) + b;
			};

			var easeOutCirc = function (t, b, c, d) {
				t /= d;
				t--;
				return c * Math.sqrt(1 - t * t) + b;
			};

			var spatialhashing = {};
			var ceilHeight = 84;
			function getHashItem(item) {
				return Math.round(item[0] / ceilHeight) + '-' + Math.round(item[1] / ceilHeight);
			}

			function addItem(item) {
				var hash = getHashItem(item);
				spatialhashing[hash] = spatialhashing[hash] || [];
				spatialhashing[hash].push(item);
			}

			function getHash(x, y) {
				return getHashItem([x, y]);
			}

			function collideElements(item) {
				var list = {};
				var elements = [];
				for (var i = 0; i < 9; i++) {
					var hash = getHash(item[0] + (i % 3 - 1) * ceilHeight, item[1] + (~~(i / 3) - 1) * ceilHeight);
					if (!list[hash]) {
						list[hash] = 1;
						var elements = spatialhashing[hash];
						for (var i = 0; elements && i < elements.length; i++) {
							if (getHypo(item[1] - elements[i][1], item[0] - elements[i][0]) < elements[i][2] + item[2]) {
								return elements[i]
							}
						}
					}
				}

			} var BADCOLOR_FRAG = 'precision highp float;\nuniform vec2 dim;\nuniform sampler2D tex;\nvarying vec2 uv;\nuniform float time;\nuniform vec3 colors;\n\n// bad color\n// play with rand,\n// and colors to display, rgb, rb, rg, gb, r, g, b\n// this glitch requires a black cortain like the one in gameover\nvoid main (){\n  float rand = sin(time);\n  vec4 col = texture2D(tex, uv);\n  vec4 col_r = texture2D(tex, uv + vec2((-15. / dim.x), 0));\n  vec4 col_l = texture2D(tex, uv + vec2((15. / dim.x), 0));\n  vec4 col_g = texture2D(tex, uv + vec2((-7.5 / dim.x), 0));\n  if(colors.r==1.){\n    col.r = col.r + col_l.r * max(1., sin(uv.y * dim.y * 1.2)) * rand;\n  }\n  if(colors.g==1.){\n   col.b = col.b + col_r.b * max(1., sin(uv.y * dim.y * 1.2)) * rand;\n  }\n  if(colors.b==1.){\n   col.g = col.g + col_g.g * max(1., sin(uv.y * dim.y * 1.2)) * rand;\n  }\n   gl_FragColor.rgba = col.rgba;\n}';
			var CRT_FRAG = 'precision highp float;\nuniform vec2 dim;\nuniform sampler2D tex;\nvarying vec2 uv;\nuniform float time;\nuniform vec3 colors;\n\nvoid main() {\n    vec2 coord = uv * dim;\n    coord -= dim/2.;\n    float dis = length(coord);\n    if (dis < 600.) {\n        float percent = dis / 600.;\n        coord *= mix(1., smoothstep(0.0, 600. / dis, percent), .125);\n    }\n    coord += dim/2.;\n    vec4 color = texture2D(tex, coord / dim);\n\n    float dist = distance(uv, vec2(.5, .5));\n    color.rgb *= smoothstep(.8, .2*.8, dist);\n\n    gl_FragColor = color;\n\n}\n';
			var CUT_FRAG = 'precision highp float;\nuniform vec2 dim;\nuniform sampler2D tex;\nvarying vec2 uv;\nuniform float time;\nuniform vec3 colors;\n\n// cut slide nice glitch!\n// play with rand and val1 val2 \nvoid main (){\n   float val1 = 5.;\n   float val2 = .5;\n   vec2 pos = uv * dim;\n   vec2 posOffset = pos + vec2(floor(sin(pos.y / val1 * time + time * time)) * val2 * time, 0);\n   posOffset = posOffset / dim;\n   vec4 col = texture2D(tex, posOffset);\n   gl_FragColor.rgba = col.rgba;\n}';
			var GLOW_FRAG = 'precision highp float;\nuniform vec2 dim;\nuniform sampler2D tex;\nvarying vec2 uv;\nuniform float time;\nuniform vec3 colors;\n\nvoid main (){ \n   vec2 pos = uv * dim;\n   vec4 col = texture2D(tex, uv);\n   vec4 gws = vec4(.0);\n   float rand = .02*sin(time)+.3;\n   float weight = .03;\n   \n   vec4 col_r = texture2D(tex, uv + vec2((-15. / dim.x) * rand, 0));\n   //glow\n   for (int i = 0; i <9; i++) {\n     float miw = float(mod(float(i), 4.));\n     float idw = float(i / 3);\n     vec2 v1 = vec2(pos.x + miw, pos.y + idw);\n     vec2 v2 = vec2(pos.x - miw, pos.y + idw);\n     vec2 v3 = vec2(pos.x + miw, pos.y - idw);\n     vec2 v4 = vec2(pos.x - miw, pos.y - idw);\n     gws += texture2D(tex, v1 / dim) * weight;\n     gws += texture2D(tex, v2 / dim) * weight;\n     gws += texture2D(tex, v3 / dim) * weight;\n     gws += texture2D(tex, v4 / dim) * weight;\n   }\n   col += gws;\n   // chromatic distorsion \n   vec4 col_l = texture2D(tex, uv + vec2((8. / dim.x) * rand, 0));\n   vec4 col_g = texture2D(tex, uv + vec2((-7.5 / dim.x) * rand, 0));\n   float val = max(1., sin(uv.y * dim.y * 1.2) * 2.5) * rand;\n   col.r = col.r + col_l.r * val;\n   col.b = col.b + col_r.b * val;\n   col.g = col.g + col_g.g * val;\n\n   // Noise color using random number\n   vec2 pos2 = uv*sin(time);\n   float r = fract(sin(dot(pos2.xy ,vec2(12.,78.))) * 43758.);\n   vec3 noise = vec3(r);\n   col.rgb = mix(col.rgb, noise, .015);\n\n\n\n   gl_FragColor.rgba = col;\n}\n';
			var SLIT_FRAG = 'precision highp float;\nuniform vec2 dim;\nuniform sampler2D tex;\nvarying vec2 uv;\nuniform float time;\nuniform vec3 colors;\n\n// SlitScanFilter\n// play with time\nvoid main (){\n   vec2 pos = uv * dim;\n   vec2 texCoord = vec2(3.+floor(pos.x/time)*time ,pos.y);\n   vec4 col = texture2D(tex, texCoord / dim);\n   gl_FragColor.rgba = col.rgba;\n} \n';
			var SWELL_FRAG = 'precision highp float;\nuniform vec2 dim;\nuniform sampler2D tex;\nvarying vec2 uv;\nuniform float time;\nuniform vec3 colors;\n\n// effects for enemies, totems and corruption\nvoid main (){\n   vec4 col_s = texture2D(tex, uv);\n   if(time==.0){\n   	gl_FragColor.rgba = col_s.bgra;\n   }else{\n   	gl_FragColor.rgba = col_s.rgba;\n   }\n   \n}\n';
			var TWIST_FRAG = 'precision highp float;\nuniform vec2 dim;\nuniform sampler2D tex;\nvarying vec2 uv;\nuniform float time;\nuniform vec3 colors;\n\n// twist glitch temp\n// 4 values to play...\nvoid main (){\n   float rand = .3; //2.3\n   float timer = .3; // 11.0\n   float val2 = 10.*time;  //2.5\n   float val3 = 10.*time; //167.0\n   float trueWidth = dim.x;\n   float trueHeight = dim.y;\n   vec2 pos = uv * dim;\n   vec2 texCoord = vec2(max(3., min(float(trueWidth), pos.x + sin(pos.y / (153.25 * rand * rand) * rand + rand * val2 + timer * 3.) * val3)), max(3., min(float(trueHeight), pos.y + cos(pos.x/(251.57 * rand * rand) * rand + rand * val2 + timer * 2.4) * val3)- 3.));\n   vec4 col = texture2D(tex, texCoord / dim);\n   gl_FragColor.rgba = col.rgba;\n}';
			var STATIC_VERT = 'attribute vec2 p;\nvarying vec2 uv;\n\nvoid main() {\n  gl_Position = vec4(p,.0,1.);\n  uv = .5 * (p+1.);\n}\n';

			if (DEBUG) {
				var _fps_ = new Stats();
				var _processing_ = new Stats();
				var _memory_ = new Stats();
				var _enemies_ = new Stats();
				var enemiesPanel = _enemies_.addPanel(new Stats.Panel('enemies', '#ff8', '#221'));
				_fps_.dom.style.left = '0px';
				_processing_.dom.style.left = '100px';
				_memory_.dom.style.left = '200px';
				_enemies_.dom.style.left = '300px';
				_fps_.showPanel(0);
				_processing_.showPanel(1);
				_memory_.showPanel(2);
				_enemies_.showPanel(3);
				document.body.appendChild(_fps_.dom);
				document.body.appendChild(_processing_.dom);
				document.body.appendChild(_memory_.dom);
				document.body.appendChild(_enemies_.dom);
				console.log('new loaded', new Date())
			}
			var glprops = { preserveDrawingBuffer: true };
			var gl = c.getContext('webgl', glprops) || c.getContext('experimental-webgl', glprops),
				ctx = g.getContext('2d'),
				FW = 800,
				FH = 600,
				GAME_MARGIN = 0,
				GAME_Y_MARGIN = GAME_MARGIN,
				GAME_INC_PADDING = 80,
				W = FW - 2 * GAME_MARGIN,
				H = FH - 2 * GAME_Y_MARGIN,
				borderLength = 2 * (W + H + 2 * GAME_INC_PADDING),
				storage = localStorage,
				shakeScreen = [0, 0],
				glitchTime = 0,
				frame = 0,
				GLITCH = [0, 0, 0, 0, 0, 0, 0],
				onyxMode = false,
				onyxModeAvailable = !!storage.getItem('onyx'),
				launchFromOnyxMode = false;
			// DOM
			d.style.webkitTransformOrigin = d.style.transformOrigin = "0 0";

			g.width = c.width = W;
			g.height = c.height = H;
			c.style.top = GAME_Y_MARGIN + "px";
			c.style.left = GAME_MARGIN + "px";
			document.oncontextmenu = function (e) {
				e.preventDefault();
			};

			// WebGL
			gl.viewport(0, 0, W, H);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

			var buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
				-1.0, -1.0,
				1.0, -1.0,
				-1.0, 1.0,
				-1.0, 1.0,
				1.0, -1.0,
				1.0, 1.0
			]), gl.STATIC_DRAW);

			var glowShader = glCreateShader(STATIC_VERT, GLOW_FRAG);
			gl.uniform2f(glUniformLocation(glowShader, 'dim'), W, H);
			var crtShader = glCreateShader(STATIC_VERT, CRT_FRAG);
			gl.uniform2f(glUniformLocation(crtShader, 'dim'), W, H);
			var badColorShader = glCreateShader(STATIC_VERT, BADCOLOR_FRAG);
			gl.uniform2f(glUniformLocation(badColorShader, 'dim'), W, H);
			var cutShader = glCreateShader(STATIC_VERT, CUT_FRAG);
			gl.uniform2f(glUniformLocation(cutShader, 'dim'), W, H);
			var twistShader = glCreateShader(STATIC_VERT, TWIST_FRAG);
			gl.uniform2f(glUniformLocation(twistShader, 'dim'), W, H);
			var swellShader = glCreateShader(STATIC_VERT, SWELL_FRAG);
			gl.uniform2f(glUniformLocation(swellShader, 'dim'), W, H);
			var slitShader = glCreateShader(STATIC_VERT, SLIT_FRAG);
			gl.uniform2f(glUniformLocation(slitShader, 'dim'), W, H);

			var fbo1 = glCreateFBO();
			var fbo2 = glCreateFBO();

			var textureGame = glCreateTexture();
			gl.bindTexture(gl.TEXTURE_2D, textureGame);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

			var colors = [
				'#FAFAFA', // Diamond
				'#004080', // Sapphire
				'#808000', // Topaz
				'#400000', // Garnet
				'#C8C8C8', // Pearl
				'#C8C8C8', // Pearl
				'#408080', // Jadeite
				'#050505', // Onyx
				'#004080', // Sapphire
				'#004080', // Sapphire
				'#408080', // Jadeite
				'#050505', // Onyx
				'#004080', // Sapphire
				'#004080', // Sapphire
				'#400080', // Amethyst
				'#808000', // Topaz
				'#400000', // Garnet
				'#400080', // Amethyst
				'#408080', // Jadeite
				'#050505', // Onyx
				'#004080', // Sapphire
				'#004080', // Sapphire
				'#050505', // Onyx
				'#050505', // Onyx
				'#050505', // Onyx
				'#400000', // Garnet
				'#808000', // Topaz
				'#050505', // Onyx
				'#400000', // Garnet
				'#400000', // Garnet
				'#808000', // Topaz
				'#408080', // Jadeite
				'#408080', // Jadeite
				'#400000', // Garnet
				'#400000', // Garnet
				'#400000', // Garnet
				'#808000', // Topaz
				'#808000', // Topaz
				'#050505', // Onyx
			];

			function setContextAtrribute(index, attribute, custom) {
				ctx[['strokeStyle', 'fillStyle', 'lineWidth'][attribute || 0]] = custom || colors[index];
			}

			function setRandomColor(r, r2, g, g2, b, b2, a, a2) {
				var value = 'rgba(' + ~~getRandomValue(r, r2) + ',' + ~~getRandomValue(g, g2) + ',' + ~~getRandomValue(b, b2) + ',' + getRandomValue(a, a2) + ')';
				setContextAtrribute(-1, 1, value);
			}

			function setFrameBuffer(param1, param2, shader, time, colors) {
				glBindFBO(param1);
				glBindShader(shader);
				gl.uniform1i(glUniformLocation(shader, 'tex'), glBindTexture(param2, 0));
				if (time != undefined) {
					gl.uniform1f(glUniformLocation(shader, 'time'), time);
				}
				if (colors) {
					gl.uniform3fv(glUniformLocation(shader, 'colors'), colors);
				}
				gl.drawArrays(gl.TRIANGLES, 0, 6);
			}
			function drawPostProcessing(time) {
				glSetTexture(textureGame, g);
				glitchTime--;
				for (var i = 0; i < GLITCH.length; i++) { GLITCH[i]--; }

				setFrameBuffer(fbo1, textureGame, badColorShader, (frame / 60) % 180, [(glitchTime + 1 > 0 || GLITCH[0] > 0) ? 1 : 0, (glitchTime + 2 > 0 || GLITCH[1] > 0) ? 1 : 0, (glitchTime > 0 || GLITCH[2] > 0) ? 1 : 0]);
				setFrameBuffer(fbo2, glGetFBOTexture(fbo1), cutShader, (glitchTime > 0 || GLITCH[3] > 0) ? 15 : 0);
				setFrameBuffer(fbo1, glGetFBOTexture(fbo2), twistShader, (glitchTime + 1 > 0 || GLITCH[4] > 0) ? 1 : 0);
				setFrameBuffer(fbo2, glGetFBOTexture(fbo1), swellShader, (GLITCH[7] > 0 && frame % 3 == 0) ? 0 : 1);
				setFrameBuffer(fbo1, glGetFBOTexture(fbo2), slitShader, (glitchTime > 0 || GLITCH[5] > 0) ? 9 : 1);
				setFrameBuffer(fbo2, glGetFBOTexture(fbo1), glowShader, frame);
				setFrameBuffer(fbo1, glGetFBOTexture(fbo2), crtShader);

				gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				gl.drawArrays(gl.TRIANGLES, 0, 6);
				gl.flush();
			}

			var coords = [0, 0, 0];

			c.onmousedown = function (e) {
				coords[2] = e.which == 3 ? 0 : 1;
				coords[3] = e.which == 3 ? 1 : 0;
				e.preventDefault();
			}

			c.onmouseup = function (e) {
				coords[2] = 0;
				coords[3] = 0;
				e.preventDefault();
			}

			c.onmousemove = function (e) {
				if (GLITCH[6] > 0) return;
				coords[0] = e.offsetX * FW / c.offsetWidth;
				coords[1] = e.offsetY * FH / c.offsetHeight;
			}

			var keyMap = 0;
			var keys = {
				'65': 1, // A
				'87': 2, // W
				'68': 4, // D
				'83': 8  // S
			}

			document.onkeydown = function (e) {
				var key = e.keyCode || e.which;
				if (keys[key]) {
					keyMap |= keys[key];
					e.preventDefault();
				}
			}

			document.onkeyup = function (e) {
				var key = e.keyCode ? e.keyCode : e.which;
				if (keyMap & keys[key]) {
					keyMap ^= keys[key];
					e.preventDefault();
				}
			}

			var spatialhashing, mapSize, tileset, gameOver, mapPixels, map, slowMotion, viewPort, enemies, ship, shipShape, bullets, particles, message, particleZ, score, glitchStoped, triggers, bigKiller, times, newRecord;
			function init() {
				spatialhashing = {},
					mapSize = 21,
					tileset = 40,
					gameOver = false,
					frame = 0,
					mapPixels = mapSize * tileset,
					map = [],
					slowMotion = 0.3,
					viewPort = [(FW - mapPixels) / 2, (FH - mapPixels) / 2, FW / 2 - 30, FH / 2 - 30],
					enemies = [],
					ship = [tileset * 10.5, tileset * 10.5, 16, 0, 150, 0, 0, 12, 0, 0],
					shipShape = [[0, 1, 0, -1], [-1, 1, 0.5, 1]],
					bullets = [],
					particles = [],
					message = '',
					particleZ = Math.PI / 2,
					score = 0,
					glitchTime = 0,
					level = 1,
					GLITCH = [0, 0, 0, 0, 0, 0, 0, 0],
					glitchStoped = false,
					triggers = {
						// Level 1
						500: [1, sequence4],
						2500: [0, 10, 5, 10],
						// Level 2
						8999: [5, 'fuck?!'],
						10500: [1, sequence3],
						10800: [8, 2],
						11000: [0, 5, 5, 10],
						18000: [0, 15, 15, 10],
						18001: [5, 'what the fuck?!'],
						25000: [0, 15, 5, 10],
						31000: [0, 5, 15, 10],
						37000: [0, 10, 11, 11],
						37500: [1, sequence1],
						46000: [5, 'what the fuck is going on?!'],
						// Level 3
						48500: [2, 10, 0, 0, 0, 10, 10, 10],
						49000: [2, 10, 10, 10, 15, 10, 20, 10],
						49001: [4, sequence3, 1],
						49002: [4, sequence1, 1],
						49003: [4, sequence4, 1],
						49500: [8, 3],
						50004: [2, 60, 60, 68, 55, 50, 45, 60],
						51000: [4, sequence3, 138],
						51001: [4, sequence1, 138],
						51002: [4, sequence4, 138],
						51003: [5, 'who the fuck are you?!'],
						// Level 4
						52000: [0, 4, 10, 11],
						53000: [0, 14, 10, 10],
						55550: [5, 'what the fuck are you doing?!'],
						61000: [0, 10, 16, 11],
						61003: [5, 'why the fuck are you doing this?!'],
						66550: [5, 'what the fuck do you want?!'],
						67000: [0, 16, 10, 11],
						68000: [0, 6, 10, 10],
						72000: [0, 10, 4, 11],
						// Level 5
						80501: [2, 1000, 0, 0, 0, 0, 0, 10],
						83000: [0, 10, 9, 12],
						83500: [1, sequence2],
						95050: [5, 'if you don\'t fucking stop...'],
						99950: [5, 'YOU WILL FUCKING DIE!'],
						99980: [8, 4],
						100000: [0, 10, 1, 12],
						103050: [5, ''],
						106000: [0, 1, 10, 12],
						111000: [0, 19, 10, 12],
						116000: [0, 10, 19, 12],
						// Level 6
						140000: [8, 5],
						140001: [5, 'LAST CHANCE MOTHERFUCKER!'],
						// Level 7
						141600: [0, 10, 12, 10],
						141601: [0, 12, 13, 10],
						141602: [0, 12, 15, 10],
						141603: [0, 10, 16, 10],
						141604: [0, 8, 15, 10],
						141605: [0, 8, 13, 10],
						145050: [5, 'THAT\'S'],
						156800: [6, 'IT,'],
						156900: [6, 'YOU'],
						157000: [0, 10, 14, 13],
						180000: [6, 'ARE'],
						180100: [6, 'GOING'],
						180200: [6, 'TO'],
						180300: [6, 'DIE!'],
						181000: [8, 6],
						// Level 8
						182000: [7, sequence1],
						182050: [7, sequence2],
						182100: [7, sequence3],
						182150: [7, sequence4],
						185100: [2, 300, 0, 300, 0, 0, 0, 0],
						// Level 9
						187000: [0, 10, 10, 14],
						189000: [1, sequence1],
						189001: [1, sequence2],
						189002: [1, sequence3],
						189003: [1, sequence4],
						// Level 10
						300100: [1, sequence4],
						305000: [0, 10, 5, 10],
						308000: [1, sequence3],
						310000: [0, 10, 6, 11],
						311000: [1, sequence4],
						315000: [0, 14, 6, 10],
						317000: [0, 14, 14, 10],
						319000: [0, 6, 14, 10],
						320000: [0, 6, 6, 10],
						335000: [0, 11, 11, 12],
						336000: [0, 9, 11, 12],
						337000: [0, 11, 9, 12],
						338000: [0, 9, 9, 12],
						350000: [0, 19, 19, 11],
						352000: [0, 1, 19, 11],
						354000: [0, 1, 1, 11],
						355000: [0, 19, 1, 11],
						365000: [0, 10, 8, 10],
						366000: [0, 11, 9, 10],
						367000: [0, 12, 10, 10],
						368000: [0, 11, 11, 10],
						369000: [0, 10, 12, 10],
						370000: [0, 9, 11, 10],
						371000: [0, 8, 10, 10],
						372000: [0, 9, 9, 10],
						395000: [0, 1, 1, 12],
						395001: [0, 1, 19, 12],
						395002: [0, 19, 19, 12],
						395003: [0, 20, 1, 12],
						395004: [0, 10, 10, 12],
						425000: [0, 0, 10, 13],
						425001: [0, 20, 10, 13],
						570001: [0, 10, 10, 13]
					},
					bigKiller = undefined;

				for (var i = 0; i < mapSize; i++) {
					map.push([]);
					for (var j = 0; j < mapSize; j++) {
						map[i].push([]);
					}
				}
				for (var i = 0; i < mapSize - 1; i++) {
					if (i == 10) continue;
					triggers[450000 + i * 6000] = [0, i, i, 10];
					triggers[453000 + i * 6000] = [0, mapSize - i - 1, i, 10];
				}
				times = Object.keys(triggers).map(function (element) { return parseInt(element) });
				map[5][5] = 1;
				record = parseFloat(storage.getItem('record') || 0);
				for (var i = 0; buttons && i < buttons.length; i++) {
					buttons[i][3] = false;
				}
				newRecord = false;
				randomGlitch();
				loadOnyx();
			}

			function loadOnyx() {
				if (onyxMode) {
					shipShape = [[0, -0.5, -0.25, -1, -0.5, -0.4, -0.5, -0.25, 0, 0.25, 0.5, 0.4, 0.5, 1, 0.25, 0.5,], [-0.25, 0, -1, 0.25, 0.75, 0.5, 0.25, 0.2, 0.8, 0.2, 0.25, 0.5, 0.75, 0.25, -1, 0]];
					ship[4] = 160;
					ship[2] = 20;
					ship[7] = 22;
				}
				if (launchFromOnyxMode) {
					score = 300000;
					level = 7;
					for (var i = times.length - 1; i >= 0; i--) {
						if (times[i] < 300000) {
							times.splice(i, 1);
						}
					}
				}
			}

			var splashScreen = true;
			var animationLine = 0;
			var distanceLine = 30;
			var controlHelp = false;
			var fade = 0;

			function drawDiagonal(x, y, width, vertical, offset) {
				ctx.moveTo(x, y);
				ctx.lineTo(x + (vertical ? offset : width), y + (vertical ? width : offset));
			}
			function drawLine(x, y, width, vertical) {
				drawDiagonal(x, y, width, vertical, 0);
			}
			function crossLine(x, y, width) {
				drawLine(x, y, width, true);
				drawLine(y, x, width);
			}

			function drawSplash() {
				ctx.save();
				ctx.beginPath();
				setContextAtrribute(23, 1);
				ctx.fillRect(0, 0, FW, FH);
				setContextAtrribute(0);

				var halfHeight = FH / 2;
				var horizon = distanceLine * 2;
				ctx.beginPath();
				for (var i = 0; i < halfHeight / distanceLine; i++) {
					var dis = easeInQuad(i * distanceLine + animationLine, halfHeight + horizon, halfHeight, halfHeight);
					setContextAtrribute(1);
					drawLine(0, dis + 0.5, FW);
				}
				ctx.stroke();
				ctx.beginPath();
				for (var i = 0; i < halfHeight / distanceLine; i++) {
					var dis = easeInQuad(i * distanceLine + animationLine, halfHeight + horizon, halfHeight, halfHeight);
					setContextAtrribute(2);
					drawLine(0, FH - dis - 0.5, FW);
				}
				ctx.stroke();
				var limit = halfHeight - horizon;
				setContextAtrribute(2);
				ctx.beginPath();
				drawLine(0, limit, FW)
				drawLine(FW / 2, limit, -limit, true);
				ctx.stroke();

				setContextAtrribute(1);
				ctx.beginPath();
				drawLine(0, FH - limit, FW)
				drawLine(FW / 2, FH - limit, limit, true);
				ctx.stroke();
				ctx.beginPath();
				for (var i = 1; i < FW / (distanceLine * 2); i++) {
					var offset = i * i * 5 + 25;
					setContextAtrribute(2);
					drawDiagonal(i * distanceLine + FW / 2, limit, -limit, true, offset);
					drawDiagonal(-i * distanceLine + FW / 2, limit, -limit, true, -offset);
				}
				ctx.stroke();
				ctx.beginPath();
				for (var i = 1; i < FW / (distanceLine * 2); i++) {
					var offset = i * i * 5 + 25;
					setContextAtrribute(1);
					drawDiagonal(i * distanceLine + FW / 2, FH - limit, limit, true, offset);
					drawDiagonal(-i * distanceLine + FW / 2, FH - limit, limit, true, -offset);
				}
				ctx.stroke();

				if (controlHelp) {
					displayWord('controls', 400, 130, 12, [0, 16]);
					displayWord('move   wasd', 400, 250, 12, [0, 0]);
					displayWord('fire   lmb', 400, 290, 12, [0, 0]);
					displayWord('phase  rmb', 400, 330, 12, [0, 0]);
				} else {
					displayWord('geowar', 400, 50, 9, [0, 0]);
					displayWord('onyx', 400, 270 - fade * 50, 30 * (1 + fade), [0, 9, 0, 9]);
					displayWord('motion', 400, 310 + fade * 50, 20 * (1 + fade), [0, 1, 0]);
					displayWord('pictures', 400, 520, 9, [0, 10]);
				}

				ctx.closePath();
				ctx.fill();
				ctx.stroke();
				ctx.restore();
			}

			function updateSplash() {
				animationLine++;
				if (animationLine > distanceLine) {
					animationLine = 0;
				}
			}

			function launchGame() {
				fade = 0.01;
			}

			function launchOnyxMode() {
				launchFromOnyxMode = true;
				onyxMode = true;
				launchGame();
			}
			init();
			var bannerScreen = false;
			var bannerMessage = '';
			var bannerCounter = 0;
			function launchBanner(message, length) {
				GLITCH[6] = 30;
				bannerCounter = length || 30;
				glitchTime = 10;
				bannerMessage = message;
			}

			function drawBanner() {
				var widthSequence = [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20];
				ctx.save();
				ctx.beginPath();
				setContextAtrribute(2, 1);
				ctx.fillRect(0, 0, FW, FH);
				displayWord(bannerMessage, 430, 180, bannerMessage.length < 5 ? 120 : 70, widthSequence);
				ctx.closePath();
				ctx.fill();
				ctx.restore();
			}

			var endMessages = [
				'your skill has proven',
				'to be quite impressive.',
				'but, what lies ahead',
				'will certainly present',
				'you with an overwhelming',
				'challenge for you to',
				'attempt to overcome...'];

			var endBannerCounter = 0;
			var bannerEndMessage;
			function updateEnds() {
				switch (endBannerCounter) {
					case 90:
						launchBanner('onyx', 30);
						break;
					case 120:
						launchBanner('motion', 30);
						break;
					case 150:
						launchBanner('pictures,', 30);
						break;
					case 180:
						launchBanner('presents...', 120);
						break;
					case 185:
						GLITCH = [100, 100, 100, 0, 0, 0, 0];
						break
					case 215:
						GLITCH = [100, 100, 100, 100, 100, 100, 100];
						break;
					case 320:
						bannerMessage = '';
						break;
					case 434:
						totemDieShakes = 0;
						break;
				}

				if (endBannerCounter > 435 && endBannerCounter < 1694) {
					bannerMessage = endMessages[~~((endBannerCounter - 435) / 180)];
				}

				if (endBannerCounter > 1694) {
					bannerEndMessage = false;
					score = 300000;
					level = 7;
					enemies = [];
					bullets = [];
					onyxMode = true;
					storage.setItem('onyx-onyxmode', 'onyx');
					loadOnyx();
				}
				endBannerCounter++;
			}

			function drawBannerEnds() {
				if (endBannerCounter < 300) return;
				var widthSequence = [0, 0, 0, 0];
				ctx.save();
				ctx.beginPath();
				if (endBannerCounter < 436) {
					setContextAtrribute(-1, 1, 'rgba(5,5,5,' + (1 - (436 - endBannerCounter) / 120) + ')');
					ctx.fillRect(0, 0, FW, FH);

				} else {
					setContextAtrribute(23, 1);
					ctx.fillRect(0, 0, FW, FH);
					displayWord(bannerMessage, 400, 250, 16, widthSequence);
				}
				ctx.closePath();
				ctx.fill();
				ctx.restore();
			}

			function checkRecord() {
				newRecord = score > record;
				if (!newRecord) return;
				record = score;
				storage.setItem('record', score);
				buttons[1][3] = true;
				buttons[2][3] = true;
			}

			var locationref = 'https://onyxmotionpictures.com/geowar';

			function baseMessage() {
				return 'you earned ' + score.toFixed() + ' ' + (onyxMode ? '#onyxMode ' : '') + 'points in Geo War! THANKS FOR PLAYING! ';
			}

			function followTikTok() {
				var message = baseMessage() + locationref;
				var link = encodeURIComponent(message);
				window.open('https://www.tiktok.com/@onyxmotionpictures/' + link);
			}

			function followInstagram() {
				var link = encodeURIComponent(locationref) + '&description=' + encodeURIComponent(baseMessage());
				window.open('https://www.instagram.com/onyxmotionpictures/' + link);
			}

			var fullscreen = false;
			function toggleFullscreen(evt) {
				if (document.fullscreenEnabled) {
					fullscreen ? document.exitFullscreen() : document.body.requestFullscreen();
				} else if (document['webkitFullscreenEnabled']) {
					fullscreen ? document.webkitExitFullscreen() : document.body.webkitRequestFullscreen();
				} else if (document.mozFullScreenEnabled) {
					fullscreen ? document.mozCancelFullScreen() : document.body.mozRequestFullScreen();
				}
				fullscreen = !fullscreen;
				evt.preventDefault();
			}
			document.getElementById('f').onclick = toggleFullscreen;

			function getRandomValue(value, offset) {
				return Math.random() * (value || 1) + (offset || 0);
			}

			function randomSign() {
				return getRandomValue() > 0.5 ? 1 : -1;
			}

			function randomGlitch() {
				var tempDuration = getRandomValue(10, 5);
				GLITCH = [tempDuration, tempDuration, tempDuration, getRandomValue(10, 5), getRandomValue(10, 5), getRandomValue(10, 5), 0];
			}

			function toggleControls() {
				play(shipSpeedUp);
				controlHelp = !controlHelp;
				buttons[3][3] = !controlHelp;
				buttons[5][3] = !controlHelp && onyxModeAvailable;
				buttons[4][5] = controlHelp ? '' : 'controls';
			}

			var buttons = [[250, 320, 300, false, 10, 'relaunch', false, false, launchGame],
			[120, 460, 250, false, 11, 'tiktok', false, false, followTikTok],
			[430, 460, 250, false, 12, 'instagram', false, false, followInstagram],
			[240, 380, 320, true, 13, 'launch', false, false, launchGame],
			[280, 440, 240, true, 13, 'controls', false, false, toggleControls],
			[280, 130, 240, onyxModeAvailable, 16, ' onyx ', false, false, launchOnyxMode]];

			function drawButtons() {
				for (var i = 0; i < buttons.length; i++) {
					var button = buttons[i];
					if (!button[3]) continue;
					var colorIndex = button[7] ? 14 : button[4];
					setContextAtrribute(colorIndex);
					setContextAtrribute(-1, 2, 2);
					ctx.strokeRect(button[0], button[1], button[2], 42);
					displayWord(button[5], button[0] + button[2] / 2, button[1] + 9, 12, [0, colorIndex]);
				}
			}

			function updateButtons() {
				for (var i = 0; i < buttons.length; i++) {
					var button = buttons[i];
					if (!button[3] || coords[0] < button[0] || coords[0] > button[0] + button[2] || coords[1] < button[1] || coords[1] > button[1] + 42) {
						button[6] = button[7] = false;
						continue;
					}
					button[7] = true;
					if (coords[2] == 1) {
						button[6] = true;
					} else if (coords[2] == 0 && button[6]) {
						button[6] = false;
						button[8]();
					}
				}
			}

			var summons = [];

			function updateSummons() {
				for (var i = 0; i < summons.length; i++) {
					var summon = summons[i];
					summon[2] -= dt;
					if (summon[2] < 0) {
						enemies.push(createEnemy(summon[4]));
						if (summon[4][2] > 9) {
							glitchTime = 10;
							play(totemAppears);
						}
						if (summon[4][2] == 3) {
							bigKiller = enemies[enemies.length - 1];
						}
						summons.splice(i, 1);
					}
				}
			}

			function drawSummonBoss(x, y, percentage, size) {
				ctx.translate(x, y);
				ctx.beginPath();
				setContextAtrribute(-1, 1, 'rgba(64,0,0,1)')
				ctx.arc(0, 0, mapPixels * (1 - percentage), 0, Math.PI * 2);
				ctx.stroke();
				ctx.fill();
				ctx.beginPath();
				setContextAtrribute(0);
				if (percentage < 0.3) {
					ctx.moveTo(-size * percentage / 0.3, 0);
					ctx.lineTo(size * percentage / 0.3, 0);
				} else {
					setContextAtrribute(0, 1);
					ctx.bezierCurveTo(-size, 0, 0, -size * percentage / 3.5, size, 0);
					ctx.bezierCurveTo(size, 0, 0, size * percentage / 3.5, -size, 0);
					ctx.fill();
				}
				ctx.closePath();
				ctx.translate(-x, -y);
			}

			function drawSummons() {
				ctx.beginPath();
				for (var i = 0; i < summons.length; i++) {
					var summon = summons[i];
					var enemyType = summon[4][2];
					var size = necronomicon[enemyType][0];
					var percentage = easeOutQuad(summon[2], 1, -1, summon[3]);
					var x = summon[0] + viewPort[0] + shakeScreen[0];
					var y = summon[1] + viewPort[1] + shakeScreen[1];
					if (enemyType == 14) {
						drawSummonBoss(x, y, percentage, size);
						continue
					}
					setContextAtrribute(-1, 0, 'rgba(38,82,255,' + percentage + ')');
					ctx.fillRect(x - percentage * size, y - percentage * size, percentage * size * 2, percentage * size * 2);
				}
				ctx.closePath();
				ctx.fill();
				ctx.stroke();
			}

			function scheduleSummon(x, y, time, element) {
				if (element[2] == 14) {
					time *= 2;
					play(bossSummon);
				}
				summons.push([x, y, time, time, element])
			}

			var alSequence = [10, 10, 11, 11, 11, 12, 12, 10, 10, 11, 13, 10, 11, 12, 12];
			var alIndex = 0;

			function updateTrigger() {
				if (times.length > 0 && score > times[0]) {
					var trigger = triggers[times.splice(0, 1)[0]];
					var type = trigger.splice(0, 1)[0];
					switch (type) {
						case 0:
							trigger[0] = (trigger[0] + 0.5) * tileset;
							trigger[1] = (trigger[1] + 0.5) * tileset;
							scheduleSummon(trigger[0], trigger[1], 1, trigger);
							break;
						case 1:
							trigger[0].play();
							break;
						case 2:
							GLITCH = trigger;
							break;
						case 3:
							play(trigger[0])
							break;
						case 4:
							trigger[0].tempo = trigger[1];
							if (trigger[1] == 138) { trigger[0].stop(); trigger[0].play() }
							break;
						case 5:
							message = trigger[0];
							break;
						case 6:
							launchBanner(trigger[0]);
							break;
						case 7:
							trigger[0].stop()
							break;
						case 8:
							level = trigger[0]
							break;
					}

				} else if (times.length == 0) {
					if (alIndex++ >= alSequence.length) {
						alIndex = 0;
					}
					triggers[score + 5000] = [0, ~~(getRandomValue(21)), ~~(getRandomValue(21)), alSequence[alIndex]]
					times.push(score + 5000)
				}
			}

			function corruptZone(x, y, radius) {
				var col = ~~(x / tileset);
				var row = ~~(y / tileset);
				var r = Math.ceil(radius / tileset);
				for (var j = row - r; j < row + r; j++) {
					if (typeof (map[j]) == 'undefined') continue;
					for (var i = col - r; i < col + r; i++) {
						if (map[j][i] == 1 || getHypo((j + 0.5) * tileset - y, (i + 0.5) * tileset - x) >= radius) continue;
						map[j][i] = 1;
					}
				}
			}

			function removeCorruption(x, y, radius) {
				var col = ~~(x / tileset);
				var row = ~~(y / tileset);
				var r = Math.ceil(radius / tileset);
				for (var j = row - r; j < row + r; j++) {
					if (typeof (map[j]) == 'undefined') continue;
					for (var i = col - r; i < col + r; i++) {
						if (map[j][i] == 1 || getHypo((j + 0.5) * tileset - y, (i + 0.5) * tileset - x) <= radius) {
							map[j][i] = 0;
						}
					}
				}
			} var necronomicon = [
				[15, 0, 0, 0, 1, [1, 0.25, -1, 0.25], [0, -0.75, 0, 0.75], 0, 3, 0.1, 1.1],
				[15, 0, 0, 1, 4, [1, 0.3, 0, -2, 0, 0.3], [0, 1, 0.3, 0, -0.3, -1], 0, 3, 0.05, 0.8],
				[8, 0, 0, 2, 2, [1, 0.25, -1, 0.25], [0, -0.5, 0, 0.5], 0, 3.5, 0.15, 1.6],
				[20, 0, 0, 3, 9, [0, 0.25, 0.75, 0.75, 1, 0.75, 0.75, 0.25, 0, -0.25, -0.75, -0.75, -1, -0.75, -0.75, -0.25], [-1, -0.75, -0.75, -0.25, 0, 0.25, 0.75, 0.75, 1, 0.75, 0.75, 0.25, 0, -0.25, -0.75, -0.75], 0, 1, 0.12, 1.05],
				[12, 0, 0, 4, 5, [0, 0.25, 1, 0.25, 0, -0.25, -1, -0.25], [-1, -0.25, 0, 0.25, 1, 0.25, 0, -0.25], 0, 3, 0.03, 2.5, 0, 0, 0],
				[3, 0, 0, 5, 150, [1, -1, -1], [0, 1, -1], 0, 0, 0, 1.4],
				[16, 0, 0, 6, 9, [1, 0.25, -1, 0.25], [0, -0.75, 0, 0.75], 0, 0, 0, 0.6, 3.5],
				[18, 0, 0, 7, 8, [1, 0.25, -1, 0.25], [0, 0.75, 0, -0.75], 0, 0, 0, 0.8, 2.5],
				[20, 0, 0, 8, 7, [1, 0.25, -1, 0.25], [0, 0.75, 0, -0.75], 0, 0, 0, 1.2, 1.5],
				,
				[tileset / 2, 0, 0, 10, 9, [[-1, 0, 0], [0, 0, 1], [-1, 1, 0]], [[-1.5, -0.5, 0.5], [-0.5, 0.5, -1.5], [-1.5, -1.5, -0.5]], 100, 0, 7],
				[tileset / 2, 0, 0, 11, 10, [[-1, 0, 0, -1], [1, 0, 0, 1], [-1, 0, 1, 0], [-1, 0, 1, 0], [-1, 0, 0, -1], [1, 0, 0, 1]], [[-1.25, -0.5, 0.8, 0.25], [-1.25, -0.5, 0.8, 0.25], [-1.25, -0.5, -1.25, -1.8], [0.25, -0.5, 0.25, 0.8], [0.25, -0.5, -1.8, -1.25], [0.25, -0.5, -1.8, -1.25]], 100, 0, 6],
				[tileset * 0.8, 0, 0, 12, 15, [[-0.5, 0, 0.5, 0], [-0.5, 0, 0], [0.5, 0, 0], [-0.5, 0, 0], [0.5, 0, 0]], [[-0.75, -1, -0.75, -0.5], [-0.75, -0.5, 0.25], [-0.75, -0.5, 0.25], [-0.75, -1.75, -0.5], [-0.75, -1.75, -0.5]], 0.9, 0, 4, 0.004],
				[tileset * 1.2, 0, 0, 13, 50, [[0, -0.75, 0], [0, 0.75, 0], [-0.75, 0.75, 0], [-0.75, 0.75, 0], [-0.35, 0.35, 0]], [[-1, 0.5, 0], [-1, 0.5, 0], [0.5, 0.5, 0], [-0.5, -0.5, 1], [0.25, 0.25, -0.5]], 0.9, 0, 13, 0.1],
				[tileset * 2.5, 0, 0, 14, 200, [], [], 0.9, 0, 60, 0.003, 1, 0, [6, 7, 6, 7, 8]]
			];

			var invocationTimes = {
				10: 2800,
				11: 2600,
				12: 60,
				13: 200
			}

			var totemDieShakes = 0;

			function summonGuardian(enemy, j) {
				var newEnemy = createEnemy([enemy[0] + Math.cos(Math.PI * j / 3) * 10, enemy[1] + Math.sin(Math.PI * j / 3) * 10, 4])
				newEnemy[13] = enemy;
				newEnemy[9] = getAngle(newEnemy, enemy);
				newEnemy[3] = newEnemy[9] + enemy[11];
				newEnemy[15] = 0;
				newEnemy[16] = 0;
				enemies.push(newEnemy);
			}

			function createEnemy(values) {
				var enemy = values.slice(0, 2).concat(necronomicon[values[2]].slice(0));
				if (enemy[5] == 12 || enemy[5] == 14) {
					for (var j = 0; j < 6; j++) {
						summonGuardian(enemy, j);
					}
				}

				for (var j = 0; j < 12; j++) {
					var newEnemy = createEnemy([enemy[0] + Math.cos(Math.PI * 2 * j / 12 + 0.1) * 10, enemy[1] + Math.sin(Math.PI * 2 * j / 12 + 0.1) * 10, 4])
					return enemy;
				}

				function drawFace(xPath, yPath, size, index, color) {
					ctx.beginPath();
					var value = 125 - index * 20;
					setContextAtrribute(-1, 1, 'rgba(' + color + ')');
					path(xPath, yPath, size)
					ctx.closePath();
					ctx.fill()
					ctx.stroke()
				}

				function pathEnemy(enemy) {
					ctx.rotate(enemy[9])
					path(enemy[7], enemy[8], enemy[2])
					ctx.strokeRect(enemy[7][0], enemy[8][1], enemy[2] * 2, enemy[2] * 2)
					ctx.rotate(-enemy[9])
				}
				var flowerOfpoints = [];
				for (var i = 0; i < 6; i++) {
					var angle = (i - 3) * Math.PI / 3 + Math.PI / 6;
					var x = Math.cos(angle);
					var y = Math.sin(angle);
					flowerOfpoints.push(x, y);
				}
				function drawFlowerOfLife(enemy) {
					var color = 'hsla(' + enemy[3] * 20 + ',50%,60%, 0.5)';
					setContextAtrribute(-1, 2, 2);
					ctx.beginPath();
					setContextAtrribute(-1, 0, enemy[4] > 0 ? colors[3] : color);
					var relativeSize = enemy[2] / 3.5;
					ctx.arc(0, 0, relativeSize / 2, 0, Math.PI * 2, false);
					ctx.stroke();
					ctx.beginPath();
					ctx.bezierCurveTo(-relativeSize, 0, 0, -relativeSize, relativeSize, 0);
					ctx.bezierCurveTo(relativeSize, 0, 0, relativeSize, -relativeSize, 0);
					ctx.stroke();
					ctx.rotate(enemy[3]);
					for (var i = 0; i < 6; i++) {
						var x = flowerOfpoints[i * 2];
						var y = flowerOfpoints[i * 2 + 1]
						var angle = (i - 3) * Math.PI / 3;
						ctx.beginPath();
						ctx.arc(4 * x * relativeSize, 4 * y * relativeSize, relativeSize, 0, Math.PI * 2, false);
						ctx.stroke();
						ctx.beginPath();
						ctx.arc(2 * x * relativeSize, 2 * y * relativeSize, relativeSize, 0, Math.PI * 2, false);
						ctx.stroke();
						ctx.beginPath();
						ctx.moveTo(x * relativeSize * 4, y * relativeSize * 4);
						ctx.lineTo(relativeSize * 4 * flowerOfpoints[(i * 2 + 2) % 12], relativeSize * 4 * flowerOfpoints[(i * 2 + 3) % 12]);
						ctx.lineTo(relativeSize * 4 * flowerOfpoints[(i * 2 + 6) % 12], relativeSize * 4 * flowerOfpoints[(i * 2 + 7) % 12]);
						ctx.moveTo(x * relativeSize * 2, y * relativeSize * 2);
						ctx.lineTo(relativeSize * 2 * flowerOfpoints[(i * 2 + 2) % 12], relativeSize * 2 * flowerOfpoints[(i * 2 + 3) % 12]);
						ctx.lineTo(relativeSize * 2 * flowerOfpoints[(i * 2 + 6) % 12], relativeSize * 2 * flowerOfpoints[(i * 2 + 7) % 12]);
						ctx.stroke();
					}
					ctx.beginPath();
					ctx.rotate(-enemy[3]);
				}

				function blink(percentage, i) {
					if (percentage > 0.99) return 1;
					var value = percentage * 100;
					var umbral = 1 / (percentage);
					return value % (umbral) > (umbral / 2) ? 1 : 0;
				}
				var blinkValues = {};
				for (var i = 0; i < 10000; i++) {
					blinkValues[(i / 10000).toFixed(4)] = blink(i / 10000, i)
				}

				function pathTotem(totem) {
					var loading = (invocationTimes[totem[5]] - totem[9]) / invocationTimes[totem[5]];
					var green = totem[4] > 0 ? -55 : ~~(200 * loading) * blinkValues[loading.toFixed(4)];
					setContextAtrribute(totem[4] > 0 ? 15 : green == 0 ? 16 : 17)
					setContextAtrribute(16)
					for (var i = 0; i < totem[7].length; i++) {
						drawFace(totem[7][i], totem[8][i], totem[2], i, [80 + totem[4], 55 + green, 130 + ~~(green / 2), totem[4] > 0 ? 0.9 : 0.2]);
					}
				}

				function drawEnemy(enemy) {
					if (enemy[0] + viewPort[0] < 20 || enemy[0] + viewPort[0] > W - 20 || enemy[1] + viewPort[1] < 20 || enemy[1] + viewPort[1] > H - 20) return;
					var offsetX = enemy[0] + viewPort[0] + shakeScreen[0] + randomSign() * enemy[4] / 40;
					var value = (enemy[5] > 9 ? Math.sin((frame / 50) % (Math.PI * 2)) * 5 + 5 : 0);
					var offsetY = enemy[1] + viewPort[1] + shakeScreen[1] + randomSign() * enemy[4] / 40 - value;
					ctx.translate(offsetX, offsetY);
					ctx.beginPath();
					if (enemy[5] < 10) {
						setContextAtrribute(enemy[5] + 24);
						setContextAtrribute(-1, 0, 'hsla(' + enemy[5] * 36 + ',50%,60%,0.8)');
						setContextAtrribute(-1, 2, 2);
						pathEnemy(enemy);
					} else if (enemy[5] == 14) {
						drawFlowerOfLife(enemy, 1);
					} else {
						setContextAtrribute(-1, 2, 2);
						pathTotem(enemy);
					}
					ctx.closePath();
					ctx.stroke();
					ctx.translate(-offsetX, -offsetY)
				}

				var spawns = {
					10: function (enemy) {
						for (var j = 0; j < 9; j++) {
							if (j == 4) continue;
							var x = enemy[0] + (j % 3 - 1) * tileset;
							var y = enemy[1] + (~~(j / 3) - 1) * tileset;
							scheduleSummon(x, y, 0.65, [x, y, j == 1 ? 1 : 0]);
							var newEnemy = createEnemy([enemy[0] + (j % 3 - 1) * tileset, enemy[1] + (~~(j / 3) - 1) * tileset, j == 1 ? 1 : 0])
							enemies.push(newEnemy);
						}
						enemy[9] = invocationTimes[10];
					},
					11: function (enemy) {
						for (var j = 0; j < 12; j++) {
							if (j == 4) continue;
							var x = enemy[0] + (j % 3 - 1) * tileset;
							var y = enemy[1] + (~~(j / 3) - 1) * tileset;
							scheduleSummon(x, y, 0.65, [x, y, j == 1 ? 3 : 2])

							if (j == 1) bigKiller = newEnemy;
							enemies.push(newEnemy);
						}
						enemy[9] = invocationTimes[11];
					},
					12: function (enemy) {
						for (var i = 0; i < 2; i++) {
							var newEnemy = createEnemy([enemy[0], enemy[1], 5])
							newEnemy[9] = enemy[3] + i * Math.PI;
							enemies.push(newEnemy);
						}
						enemy[9] = invocationTimes[12];
					},
					13: function (enemy) {
						for (var i = 0; i < 6; i++) {
							var newEnemy = createEnemy([enemy[0], enemy[1], 5])
							newEnemy[9] = enemy[3] + (i - 3) * Math.PI / 3;
							newEnemy[12] += 0.5;
							enemies.push(newEnemy);
						}
						enemy[9] = 45;
					},
					14: function (enemy) {
						for (var i = 0; i < 6; i++) {
							var newEnemy = createEnemy([enemy[0], enemy[1], 5])
							newEnemy[9] = enemy[3] + (i - 3) * Math.PI / 3 + Math.PI / 6;
							newEnemy[12] -= 0.6;
							enemies.push(newEnemy);
						}
						if (enemy[13] % 16 == 0) {
							var newEnemy = createEnemy([enemy[0], enemy[1], enemy[15][enemy[14] % enemy[15].length]]);
							newEnemy[9] = enemy[3] / 2;
							enemies.push(newEnemy);
							enemy[14]++;
						}
						if (enemy[13] % 100 == 0) {
							for (var j = 0; j < 6; j++) {
								summonGuardian(enemy, j);
							}
						}
						enemy[9] = 70;
						enemy[13]++;
					}
				}

				function updateEnemy(enemy, index, timeAdjustedDelta) {
					if (enemy[6] <= 0) {
						enemies.splice(index, 1);
						if (enemy[5] == 5) return;
						if (enemy[5] == 14) {
							bannerEndMessage = true;
						}
						createParticles(enemy[0], enemy[1], enemy[2], necronomicon[enemy[5]][0], necronomicon[enemy[5]][0] * 2, enemy[5] + 24);
						if (enemy[5] > 9) {
							removeCorruption(enemy[0], enemy[1], enemy[10]);
							totemDieShakes = 4;
							play(totemDestroyed);
						} else {
							play(enemyDie);
						}
						return;
					}

					if (enemy[4] > 0) {
						enemy[4] -= 50;
					}

					if (enemy[5] < 10) {
						if (enemy[10] * (enemy[9] - enemy[3]) > 0) {
							if (enemy[5] == 2) {
								enemy[3] = getAngle(enemy, bigKiller || [0, 0]);
							} else if (enemy[5] == 4) {
								enemy[3] += enemy[9] + enemy[11];
							} else {
								enemy[3] = getAngle(enemy, ship);
							}
							enemy[10] = enemy[3] > enemy[9] ? enemy[11] : -enemy[11];
						}

						var otherEnemy = collideElements(enemy);
						if (enemy[5] == 4) {
							enemy[9] += enemy[10] * t;
						} else if (enemy[5] != 3 || (otherEnemy && otherEnemy[5] == 3)) {
							enemy[9] += (otherEnemy ? -1 : 1) * enemy[10];
						} else {
							enemy[9] += enemy[10];
						}

						if (enemy[5] == 5) {
							enemy[6] -= t / 10;
						}

						if (enemy[5] > 5 && enemy[5] < 10) {
							enemy[13] -= dt;
							if (enemy[13] < 0) {
								var coords = [(~~(enemy[0] / tileset) + 0.5) * tileset, (~~(enemy[1] / tileset) + 0.5) * tileset, enemy[5] + 4];
								scheduleSummon(coords[0], coords[1], 1, coords);
								enemies.splice(index, 1);
								return;
							}
						}

						if (enemy[5] != 4) {
							enemy[0] += Math.cos(enemy[9]) * timeAdjustedDelta * enemy[12];
							enemy[1] += Math.sin(enemy[9]) * timeAdjustedDelta * enemy[12];
						} else {
							if (enemy[13][6] < 1) {
								enemy[10] *= 0.99;
							}
							enemy[15] = tileset * 2 * (-Math.cos(enemy[16]) + 1.2);
							enemy[16] += t / 200;
							enemy[0] = enemy[13][0] + Math.cos(enemy[9]) * enemy[15];
							enemy[1] = enemy[13][1] + Math.sin(enemy[9]) * enemy[15];
						}

					} else {
						enemy[9] -= timeAdjustedDelta;
						if (enemy[5] >= 12) enemy[3] += enemy[12] * timeAdjustedDelta;
						if (enemy[9] < 0 && !gameOver) {
							spawns[enemy[5]](enemy);
						}
						enemy[10] += dt * enemy[11];
						corruptZone(enemy[0], enemy[1], enemy[10]);
					}
					addItem(enemy);
				}

				function die(killer) {
					play(shipDie);
					createParticles(ship[0], ship[1], ship[2], 10, 80, 6);
					shipShape = [[], []]
					gameOver = true;
					buttons[0][3] = true;
					t = dt * 30;
					checkRecord();
					frame = 0;
				}

				function drawPointer() {
					ctx.save();
					ctx.beginPath();
					setContextAtrribute(-1, 2, 2);
					ctx.translate(coords[0], coords[1]);
					setContextAtrribute(6);
					ctx.translate(-10, -10);
					crossLine(10, 0, 20);
					ctx.stroke();
					ctx.closePath();
					ctx.restore();
				}

				function playerUdate(dt, timeAdjustedDelta) {
					var speed = dt * ship[4] * (ship[8] > 0 ? 1.4 : 1);

					if (map[Math.round(ship[1] / tileset)] && map[Math.round(ship[1] / tileset)][Math.round(ship[0] / tileset)] == 1) {
						speed -= 0.5;
					}
					if (keyMap & keys[65]) {
						ship[0] -= speed;
						if (ship[0] < ship[2]) ship[0] = ship[2];
						if (ship[0] > viewPort[2] && ship[0] < mapPixels - viewPort[2]) viewPort[0] += speed;
						if (viewPort[0] > 32) viewPort[0] = 32;
					}
					if (keyMap & keys[87]) {
						ship[1] -= speed;
						if (ship[1] < ship[2]) ship[1] = ship[2];
						if (ship[1] > viewPort[3] && ship[1] < mapPixels - viewPort[3]) viewPort[1] += speed;
						if (viewPort[1] > 27) viewPort[1] = 27;
					}

					if (keyMap & keys[83]) {
						ship[1] += speed;
						if (ship[1] > mapPixels - ship[2]) ship[1] = mapPixels - ship[2];
						if (ship[1] > viewPort[3] && ship[1] < mapPixels - viewPort[3]) viewPort[1] -= speed;
						if (viewPort[1] < -272) viewPort[1] = -272;
					}
					if (keyMap & keys[68]) {
						ship[0] += speed;
						if (ship[0] > mapPixels - ship[2]) ship[0] = mapPixels - ship[2];
						if (ship[0] > viewPort[2] && ship[0] < mapPixels - viewPort[2]) viewPort[0] -= speed;
						if (viewPort[0] < -67) viewPort[0] = -67;
					}

					ship[3] = getAngle([ship[0] + viewPort[0], ship[1] + viewPort[1]], coords);

					ship[5] += (timeAdjustedDelta * 25 * (coords[2] * 8 + 1))
					ship[5] %= 360

					var killer = collideElements(ship);
					if (killer) die(killer);
					if (coords[2] && ship[6] <= 0 && ship[8] <= 0) {
						bullets.push([ship[0] + shake(1, 2 + ship[7] / 30), ship[1] + shake(1, 2 + ship[7] / 30), 2, ship[3] + shake(1, 0.05 + 0.001 * ship[7])])
						play(fireSounds[~~(getRandomValue(fireSounds.length))]);
						ship[6] = 1 / ship[7];
					} else {
						ship[6] -= dt;
					}

					if (coords[3] && ship[8] <= 0 && ship[9] <= 0) {
						play(shipSpeedUp);
						ship[8] = 0.55;
						ship[9] = 1.2;
					} else {
						ship[8] -= dt;
						ship[9] -= dt;
					}
				}

				function update(dt) {
					var timeAdjustedDelta = dt * ship[4] * (ship[8] > 0 ? slowMotion : 1);

					if (!gameOver) playerUdate(dt, timeAdjustedDelta);

					// bullets
					bulletsCycle: for (var i = bullets.length - 1; i >= 0; i--) {
						var bullet = bullets[i];
						bullet[0] += Math.cos(bullet[3]) * timeAdjustedDelta * bullet[2];
						bullet[1] += Math.sin(bullet[3]) * timeAdjustedDelta * bullet[2];
						if (bullet[0] < -20 || bullet[0] > mapPixels + 20 || bullet[1] < -20 || bullet[1] > mapPixels + 20) bullets.splice(i, 1);

						var enemy = collideElements(bullet);
						if (enemy) {
							if (--enemy[6] > 0) {
								createParticles(bullet[0], bullet[1], -bullet[3], 2, 10, 9);
							}
							bullets.splice(i, 1);
							enemy[4] = 200
							if (enemy[5] > 9)
								play(hitSounds[~~(getRandomValue(hitSounds.length))]);
						}
					}

					// particles
					for (var i = 0; i < particles.length; i++) {
						var particle = particles[i];
						particle[0] += Math.cos(particle[2]) * getRandomValue(3, 2);
						particle[1] += Math.sin(particle[2]) * getRandomValue(3, 2);
						if (--particle[3] < 0) particles.splice(i, 1)
					}

					// enemies 
					if (totemDieShakes > 0) totemDieShakes -= 0.1;
					spatialhashing = {};
					for (var i = enemies.length - 1; i >= 0; i--) {
						updateEnemy(enemies[i], i, timeAdjustedDelta);
					}
					updateTrigger();
					updateSummons();
				}

				function shake(cond, val) {
					return cond ? getRandomValue(val * 2, -val) : 0;
				}

				function path(xpts, ypts, size) {
					ctx.moveTo(xpts[0] * size, ypts[0] * size);
					for (var i = 1; i < xpts.length; i++) {
						ctx.lineTo(xpts[i] * size, ypts[i] * size);
					}
					ctx.lineTo(xpts[0] * size, ypts[0] * size);
				}

				function createParticles(x, y, angle, many, life, color) {
					for (var h = -many; h < many; h++) {
						particles.push([x, y, getRandomValue(particleZ * h, angle), life || 60, color]);
					}
				}

				function draw(t) {
					setContextAtrribute(7, 1);
					ctx.fillRect(0, 0, FW, FH);
					setRandomColor(180, 0, 185, 0, 185, 0, 0, 1);
					for (var i = 0; i < 6; i++)
						ctx.fillRect(~~(getRandomValue(800)), ~~(getRandomValue(600)), 2, 2);

					// map 
					ctx.save()
					var gridSize = H / mapSize
					ctx.beginPath();
					shakeScreen = !gameOver ? [shake(coords[2] || totemDieShakes > 0, totemDieShakes + 2), shake(coords[2] || totemDieShakes > 0, totemDieShakes + 2)] : [0, 0];
					setContextAtrribute(-1, 1, 'rgba(7,8,12,' + (0.2 - (ship[8] > 0 ? 0.1 : 0)) + ')');
					ctx.translate(viewPort[0] + shakeScreen[0], viewPort[1] + shakeScreen[1]);
					ctx.fillRect(0, 0, mapPixels, mapPixels);

					setContextAtrribute(1);
					ctx.beginPath();
					for (var i = 0; i <= mapSize; i++) {
						crossLine(i * tileset - 0.5, 0, mapPixels);
					}
					ctx.stroke();
					ctx.beginPath();
					setContextAtrribute(5);
					for (var i = 0; i <= mapSize; i++) {
						crossLine(i * tileset + 0.5, 0, mapPixels);
					}
					ctx.stroke();
					ctx.restore();

					// corruption 
					ctx.save();
					ctx.beginPath();
					setContextAtrribute(8, 1);
					setContextAtrribute(2);
					for (var j = 0; j < mapSize; j++) {
						for (var i = 0; i < mapSize; i++) {
							if (map[j][i] == 0) continue;
							ctx.fillRect(i * tileset + viewPort[0] + shakeScreen[0], j * tileset + viewPort[1] + shakeScreen[1], tileset, tileset);
							ctx.strokeRect(i * tileset + viewPort[0] + shakeScreen[0] - 0.5, j * tileset + viewPort[1] + shakeScreen[1] - 0.5, tileset + 2, tileset + 2);
							ctx.strokeRect(i * tileset + viewPort[0] + shakeScreen[0] + 1.5, j * tileset + viewPort[1] + shakeScreen[1] + 1.5, tileset - 2, tileset - 2);
						}
					}
					ctx.stroke();
					ctx.beginPath();
					setContextAtrribute(2);
					for (var j = 0; j < mapSize; j++) {
						for (var i = 0; i < mapSize; i++) {
							if (map[j][i] == 0) continue;
							ctx.strokeRect(i * tileset + viewPort[0] + shakeScreen[0] + 0.5, j * tileset + viewPort[1] + shakeScreen[1] + 0.5, tileset, tileset);
						}
					}
					ctx.fill();
					ctx.closePath();
					ctx.restore();
					ctx.save();
					drawSummons();
					ctx.restore();
					ctx.save();
					ctx.translate(ship[0] + viewPort[0], ship[1] + viewPort[1]);
					ctx.rotate(ship[3] + Math.PI / 2);
					setContextAtrribute(-1, 2, 2);
					setContextAtrribute(6);
					ctx.beginPath();
					path(shipShape[0], shipShape[1], ship[2]);
					ctx.closePath();
					ctx.stroke();
					ctx.restore();
					ctx.save();
					for (var i = 0; i < enemies.length; i++) {
						drawEnemy(enemies[i])
					}
					ctx.closePath();
					ctx.restore();
					ctx.save();
					setContextAtrribute(9, 1);
					for (var i = 0; i < bullets.length; i++) {
						var bullet = bullets[i];
						if (bullet[0] + viewPort[0] < 20 || bullet[0] + viewPort[0] > W - 20 || bullet[1] + viewPort[1] < 20 || bullet[1] + viewPort[1] > H - 20) continue
						ctx.beginPath();
						ctx.arc(bullet[0] + viewPort[0], bullet[1] + viewPort[1], bullet[2], 0, 2 * Math.PI, false);
						ctx.closePath();
						ctx.fill();
					}
					ctx.restore();
					ctx.save();
					setRandomColor(125, 50, 125, 50, 125, 50, 0, 1);
					setContextAtrribute(1)
					for (var i = 0; i < particles.length; i++) {
						var particle = particles[i];
						if (particle[0] + viewPort[0] < 5 || particle[0] + viewPort[0] > W - 5 || particle[1] + viewPort[1] < 5 || particle[1] + viewPort[1] > H - 5) continue
						ctx.beginPath();
						ctx.globalAlpha = particle[3] / 100;
						setContextAtrribute(particle[4], 1);
						setRandomColor(125, particle[4], 125, particle[5], 125, particle[6], 0, particle[3] / 100);
						ctx.arc(particle[0] + viewPort[0] + shakeScreen[0], particle[1] + viewPort[1] + shakeScreen[1], 2, 0, 2 * Math.PI, false);
						ctx.closePath();
						ctx.fill();
					}
					ctx.restore();
					ctx.save();
					displayWord(message, 401, 501, 14, [26, 21, 21]);
					displayWord(viewPort[0] + ' ' + viewPort[1], 402, 100, 14, '#80800050');
					if (gameOver) {
						setContextAtrribute(22, 1);
						ctx.fillRect(0, 0, mapPixels, mapPixels);
						if (onyxMode) {
							displayWord('onyx', 400, 80, 22, [0, 16]);
						}
						if (newRecord) {
							displayWord('high score', 400, 240, 22, [10, 18]);
							displayWord('geo war', 400, 400, 14, [24, 18]);
						} else {
							displayWord('you died', 400, 240, 20, [0, 13]);
						}
						displayWord(score.toFixed(0), 400, 160, newRecord ? 20 : 16, [0, 9]);
					} else {
						displayWord(level > 6 ? 'onyx' : (level + '/6'), 400, 60, 9, [0, 3]);
						displayWord(score.toFixed(0), 750, 60, 18, [32, 9], 1);
						var lrd = score > record ? 'points' : record.toFixed(0);
						displayWord(lrd, 750, 110, 9, [24, 3], 1);
					}
					ctx.restore();

				}

				var lastTime;
				function loop(t) {
					if (DEBUG) {
						_fps_.begin();
						_processing_.begin();
						_memory_.begin();
						_enemies_.begin();
					}

					if (!lastTime) lastTime = t;
					dt = (Math.min(100, t - lastTime) / 1000);
					lastTime = t;
					frame++;

					if (splashScreen) updateSplash(dt);
					else if (bannerEndMessage) updateEnds();
					else if (GLITCH[6] < 0) update(dt);

					if (splashScreen || gameOver) {
						switch (frame) {
							case 240:
							case 280:
							case 500:
								randomGlitch();
								play(openingGlitch);
								break;
							case 700:
								frame = 0;
								break;
						}
					}

					updateButtons();

					ctx.save();
					if (splashScreen) drawSplash();
					else if (!bannerScreen) draw(dt);

					if (!bannerScreen && !bannerEndMessage) drawPointer();
					ctx.save();
					drawButtons();
					ctx.restore();
					if (bannerScreen) drawBanner();
					else if (bannerEndMessage) drawBannerEnds();

					if (fade > 0) {
						fade += 0.05;
						if (fade == 0.51) play(gameStarts);
					}
					if (fade > 1) {
						splashScreen = false;
						fade = 0;
						init();
					}
					if (fade > 0 && fade < 1) {
						setContextAtrribute(-1, 1, 'rgba(200,200,200,' + fade + ')');
						ctx.fillRect(0, 0, FW, FH);
					}
					bannerScreen = bannerCounter > 0;
					if (bannerScreen) {
						bannerCounter -= 1;
					}

					ctx.restore();

					drawPostProcessing(~~(t));
					if (!gameOver && !splashScreen) score += dt * 1000 * (ship[8] > 0 ? slowMotion : 1);

					if (DEBUG) {
						_fps_.end();
						_processing_.end();
						_memory_.end();
						_enemies_.end();
						enemiesPanel.update(enemies ? enemies.length : 0, 1000);
					}
					requestAnimationFrame(loop);
				}
				requestAnimationFrame(loop);
			}
		})();
	</script>
</body>
</html>